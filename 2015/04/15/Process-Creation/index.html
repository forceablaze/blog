<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Process Creation | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ProcessProcesses are, however, more than just the executing program code (often called the text section in Unix).They also include a set of resources such as open files and pending signals, internal k">
<meta property="og:type" content="article">
<meta property="og:title" content="Process Creation">
<meta property="og:url" content="http://forceablaze.github.io/blog/2015/04/15/Process-Creation/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="ProcessProcesses are, however, more than just the executing program code (often called the text section in Unix).They also include a set of resources such as open files and pending signals, internal k">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Process Creation">
<meta name="twitter:description" content="ProcessProcesses are, however, more than just the executing program code (often called the text section in Unix).They also include a set of resources such as open files and pending signals, internal k">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://forceablaze.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Process-Creation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/04/15/Process-Creation/" class="article-date">
  <time datetime="2015-04-15T15:00:04.000Z" itemprop="datePublished">2015-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Process Creation
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Process">Process</h3><p>Processes are, however, more than just the executing program code (often called the text section in Unix).They also include a set of resources such as open files and pending signals, internal kernel data, processor state, a memory address space with one or more memory mappings, one or more threads of execution, and a data section containing global variables. 
Processes, in effect, are the living result of running program code.The kernel needs to manage all these details efficiently and transparently. Threads of execution, often shortened to thread</p>
<p><a href="https://kerker-notes.hackpad.com/process-thread-9UEQ2LVPjzv" target="_blank" rel="external">Process and Thread in Linux</a></p>
<h3 id="Process_Descriptor">Process Descriptor</h3><p>Linux 把 process 存放在一個 circual doubly linked list
, task list，process則是有個 Process Descriptor(PCB)來紀錄 process的資訊，在Linux裡叫 struct task_struct。下面來看看 task_struct長怎樣。
defined in
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;linux/sched.h&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">	atomic_t usage;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;	<span class="comment">/* per process flags, defined below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">struct</span> llist_node wake_entry;</span><br><span class="line">	<span class="keyword">int</span> on_cpu;</span><br><span class="line">	<span class="keyword">struct</span> task_struct *last_wakee;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> wakee_flips;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> wakee_flip_decay_ts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> wake_cpu;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> on_rq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> prio, static_prio, normal_prio;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> sched_class *sched_class;</span><br><span class="line">	<span class="keyword">struct</span> sched_entity se;</span><br><span class="line">	<span class="keyword">struct</span> sched_rt_entity rt;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_CGROUP_SCHED</span></span><br><span class="line">	<span class="keyword">struct</span> task_group *sched_task_group;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> sched_dl_entity dl;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	<span class="comment">/* list of struct preempt_notifier: */</span></span><br><span class="line">	<span class="keyword">struct</span> hlist_head preempt_notifiers;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> btrace_seq;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line">	<span class="keyword">int</span> nr_cpus_allowed;</span><br><span class="line">	cpumask_t cpus_allowed;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PREEMPT_RCU</span></span><br><span class="line">	<span class="keyword">int</span> rcu_read_lock_nesting;</span><br><span class="line">	<span class="keyword">union</span> rcu_special rcu_read_unlock_special;</span><br><span class="line">	<span class="keyword">struct</span> list_head rcu_node_entry;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* #ifdef CONFIG_PREEMPT_RCU */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PREEMPT_RCU</span></span><br><span class="line">	<span class="keyword">struct</span> rcu_node *rcu_blocked_node;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* #ifdef CONFIG_PREEMPT_RCU */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_TASKS_RCU</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rcu_tasks_nvcsw;</span><br><span class="line">	<span class="keyword">bool</span> rcu_tasks_holdout;</span><br><span class="line">	<span class="keyword">struct</span> list_head rcu_tasks_holdout_list;</span><br><span class="line">	<span class="keyword">int</span> rcu_tasks_idle_cpu;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* #ifdef CONFIG_TASKS_RCU */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span></span><br><span class="line">	<span class="keyword">struct</span> sched_info sched_info;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> list_head tasks;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">struct</span> plist_node pushable_tasks;</span><br><span class="line">	<span class="keyword">struct</span> rb_node pushable_dl_tasks;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> mm_struct *mm, *active_mm;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_COMPAT_BRK</span></span><br><span class="line">	<span class="keyword">unsigned</span> brk_randomized:<span class="number">1</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* per-thread vma caching */</span></span><br><span class="line">	u32 vmacache_seqnum;</span><br><span class="line">	<span class="keyword">struct</span> vm_area_struct *vmacache[VMACACHE_SIZE];</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(SPLIT_RSS_COUNTING)</span></span><br><span class="line">	<span class="keyword">struct</span> task_rss_stat	rss_stat;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* task state */</span></span><br><span class="line">	<span class="keyword">int</span> exit_state;</span><br><span class="line">	<span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line">	<span class="keyword">int</span> pdeath_signal;  <span class="comment">/*  The signal sent when the parent dies  */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> jobctl;	<span class="comment">/* JOBCTL_*, siglock protected */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Used for emulating ABI behavior of previous Linux versions */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> personality;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> in_execve:<span class="number">1</span>;	<span class="comment">/* Tell the LSMs that the process is doing an</span><br><span class="line">				 * execve */</span></span><br><span class="line">	<span class="keyword">unsigned</span> in_iowait:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Revert to default priority/policy when forking */</span></span><br><span class="line">	<span class="keyword">unsigned</span> sched_reset_on_fork:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> sched_contributes_to_load:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_MEMCG_KMEM</span></span><br><span class="line">	<span class="keyword">unsigned</span> memcg_kmem_skip_account:<span class="number">1</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> atomic_flags; <span class="comment">/* Flags needing atomic access. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> restart_block restart_block;</span><br><span class="line"></span><br><span class="line">	pid_t pid;</span><br><span class="line">	pid_t tgid;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_CC_STACKPROTECTOR</span></span><br><span class="line">	<span class="comment">/* Canary value for the -fstack-protector gcc feature */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_canary;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * pointers to (original) parent process, youngest child, younger sibling,</span><br><span class="line">	 * older sibling, respectively.  (p-&gt;father can be replaced with</span><br><span class="line">	 * p-&gt;real_parent-&gt;pid)</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct __rcu *real_parent; <span class="comment">/* real parent process */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct __rcu *parent; <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * children/sibling forms the list of my natural children</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head children;	<span class="comment">/* list of my children */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head sibling;	<span class="comment">/* linkage in my parent's children list */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *group_leader;	<span class="comment">/* threadgroup leader */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * ptraced is the list of tasks this task is using ptrace on.</span><br><span class="line">	 * This includes both natural children and PTRACE_ATTACH targets.</span><br><span class="line">	 * p-&gt;ptrace_entry is p's link on the p-&gt;parent-&gt;ptraced list.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head ptraced;</span><br><span class="line">	<span class="keyword">struct</span> list_head ptrace_entry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PID/PID hash table linkage. */</span></span><br><span class="line">	<span class="keyword">struct</span> pid_link pids[PIDTYPE_MAX];</span><br><span class="line">	<span class="keyword">struct</span> list_head thread_group;</span><br><span class="line">	<span class="keyword">struct</span> list_head thread_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> completion *vfork_done;		<span class="comment">/* for vfork() */</span></span><br><span class="line">	<span class="keyword">int</span> __user *set_child_tid;		<span class="comment">/* CLONE_CHILD_SETTID */</span></span><br><span class="line">	<span class="keyword">int</span> __user *clear_child_tid;		<span class="comment">/* CLONE_CHILD_CLEARTID */</span></span><br><span class="line"></span><br><span class="line">	cputime_t utime, stime, utimescaled, stimescaled;</span><br><span class="line">	cputime_t gtime;</span><br><span class="line"><span class="preprocessor">#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE</span></span><br><span class="line">	<span class="keyword">struct</span> cputime prev_cputime;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line">	seqlock_t vtime_seqlock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> vtime_snap;</span><br><span class="line">	<span class="keyword">enum</span> &#123;</span><br><span class="line">		VTIME_SLEEPING = <span class="number">0</span>,</span><br><span class="line">		VTIME_USER,</span><br><span class="line">		VTIME_SYS,</span><br><span class="line">	&#125; vtime_snap_whence;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nvcsw, nivcsw; <span class="comment">/* context switch counts */</span></span><br><span class="line">	u64 start_time;		<span class="comment">/* monotonic time in nsec */</span></span><br><span class="line">	u64 real_start_time;	<span class="comment">/* boot based time in nsec */</span></span><br><span class="line"><span class="comment">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> task_cputime cputime_expires;</span><br><span class="line">	<span class="keyword">struct</span> list_head cpu_timers[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> cred __rcu *real_cred; <span class="comment">/* objective and real subjective task</span><br><span class="line">					 * credentials (COW) */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> cred __rcu *cred;	<span class="comment">/* effective (overridable) subjective task</span><br><span class="line">					 * credentials (COW) */</span></span><br><span class="line">	<span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span><br><span class="line">				     - access with [gs]et_task_comm (which lock</span><br><span class="line">				       it with task_lock())</span><br><span class="line">				     - initialized normally by setup_new_exec */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">	<span class="keyword">int</span> link_count, total_link_count;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_SYSVIPC</span></span><br><span class="line"><span class="comment">/* ipc stuff */</span></span><br><span class="line">	<span class="keyword">struct</span> sysv_sem sysvsem;</span><br><span class="line">	<span class="keyword">struct</span> sysv_shm sysvshm;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line"><span class="comment">/* hung task detection */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> last_switch_count;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">	<span class="keyword">struct</span> thread_struct thread;</span><br><span class="line"><span class="comment">/* filesystem information */</span></span><br><span class="line">	<span class="keyword">struct</span> fs_struct *fs;</span><br><span class="line"><span class="comment">/* open file information */</span></span><br><span class="line">	<span class="keyword">struct</span> files_struct *files;</span><br><span class="line"><span class="comment">/* namespaces */</span></span><br><span class="line">	<span class="keyword">struct</span> nsproxy *nsproxy;</span><br><span class="line"><span class="comment">/* signal handlers */</span></span><br><span class="line">	<span class="keyword">struct</span> signal_struct *signal;</span><br><span class="line">	<span class="keyword">struct</span> sighand_struct *sighand;</span><br><span class="line"></span><br><span class="line">	sigset_t blocked, real_blocked;</span><br><span class="line">	sigset_t saved_sigmask;	<span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line">	<span class="keyword">struct</span> sigpending pending;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line">	size_t sas_ss_size;</span><br><span class="line">	<span class="keyword">int</span> (*notifier)(<span class="keyword">void</span> *priv);</span><br><span class="line">	<span class="keyword">void</span> *notifier_data;</span><br><span class="line">	sigset_t *notifier_mask;</span><br><span class="line">	<span class="keyword">struct</span> callback_head *task_works;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> audit_context *audit_context;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_AUDITSYSCALL</span></span><br><span class="line">	kuid_t loginuid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sessionid;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> seccomp seccomp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread group tracking */</span></span><br><span class="line">   	u32 parent_exec_id;</span><br><span class="line">   	u32 self_exec_id;</span><br><span class="line"><span class="comment">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed,</span><br><span class="line"> * mempolicy */</span></span><br><span class="line">	spinlock_t alloc_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Protection of the PI data structures: */</span></span><br><span class="line">	raw_spinlock_t pi_lock;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_RT_MUTEXES</span></span><br><span class="line">	<span class="comment">/* PI waiters blocked on a rt_mutex held by this task */</span></span><br><span class="line">	<span class="keyword">struct</span> rb_root pi_waiters;</span><br><span class="line">	<span class="keyword">struct</span> rb_node *pi_waiters_leftmost;</span><br><span class="line">	<span class="comment">/* Deadlock detection and priority inheritance handling */</span></span><br><span class="line">	<span class="keyword">struct</span> rt_mutex_waiter *pi_blocked_on;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">	<span class="comment">/* mutex deadlock detection */</span></span><br><span class="line">	<span class="keyword">struct</span> mutex_waiter *blocked_on;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> irq_events;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hardirq_enable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hardirq_disable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hardirq_enable_event;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hardirq_disable_event;</span><br><span class="line">	<span class="keyword">int</span> hardirqs_enabled;</span><br><span class="line">	<span class="keyword">int</span> hardirq_context;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> softirq_disable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> softirq_enable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_disable_event;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_enable_event;</span><br><span class="line">	<span class="keyword">int</span> softirqs_enabled;</span><br><span class="line">	<span class="keyword">int</span> softirq_context;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_LOCKDEP</span></span><br><span class="line"><span class="preprocessor"># <span class="keyword">define</span> MAX_LOCK_DEPTH 48UL</span></span><br><span class="line">	u64 curr_chain_key;</span><br><span class="line">	<span class="keyword">int</span> lockdep_depth;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lockdep_recursion;</span><br><span class="line">	<span class="keyword">struct</span> held_lock held_locks[MAX_LOCK_DEPTH];</span><br><span class="line">	gfp_t lockdep_reclaim_gfp;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* journalling filesystem info */</span></span><br><span class="line">	<span class="keyword">void</span> *journal_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* stacked block device info */</span></span><br><span class="line">	<span class="keyword">struct</span> bio_list *bio_list;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_BLOCK</span></span><br><span class="line"><span class="comment">/* stack plugging */</span></span><br><span class="line">	<span class="keyword">struct</span> blk_plug *plug;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* VM state */</span></span><br><span class="line">	<span class="keyword">struct</span> reclaim_state *reclaim_state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> backing_dev_info *backing_dev_info;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> io_context *io_context;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace_message;</span><br><span class="line">	siginfo_t *last_siginfo; <span class="comment">/* For ptrace use.  */</span></span><br><span class="line">	<span class="keyword">struct</span> task_io_accounting ioac;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(CONFIG_TASK_XACCT)</span></span><br><span class="line">	u64 acct_rss_mem1;	<span class="comment">/* accumulated rss usage */</span></span><br><span class="line">	u64 acct_vm_mem1;	<span class="comment">/* accumulated virtual memory usage */</span></span><br><span class="line">	cputime_t acct_timexpd;	<span class="comment">/* stime + utime since last update */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_CPUSETS</span></span><br><span class="line">	nodemask_t mems_allowed;	<span class="comment">/* Protected by alloc_lock */</span></span><br><span class="line">	seqcount_t mems_allowed_seq;	<span class="comment">/* Seqence no to catch updates */</span></span><br><span class="line">	<span class="keyword">int</span> cpuset_mem_spread_rotor;</span><br><span class="line">	<span class="keyword">int</span> cpuset_slab_spread_rotor;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* Control Group info protected by css_set_lock */</span></span><br><span class="line">	<span class="keyword">struct</span> css_set __rcu *cgroups;</span><br><span class="line">	<span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head cg_list;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_FUTEX</span></span><br><span class="line">	<span class="keyword">struct</span> robust_list_head __user *robust_list;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_COMPAT</span></span><br><span class="line">	<span class="keyword">struct</span> compat_robust_list_head __user *compat_robust_list;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> list_head pi_state_list;</span><br><span class="line">	<span class="keyword">struct</span> futex_pi_state *pi_state_cache;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PERF_EVENTS</span></span><br><span class="line">	<span class="keyword">struct</span> perf_event_context *perf_event_ctxp[perf_nr_task_contexts];</span><br><span class="line">	<span class="keyword">struct</span> mutex perf_event_mutex;</span><br><span class="line">	<span class="keyword">struct</span> list_head perf_event_list;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> preempt_disable_ip;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">struct</span> mempolicy *mempolicy;	<span class="comment">/* Protected by alloc_lock */</span></span><br><span class="line">	<span class="keyword">short</span> il_next;</span><br><span class="line">	<span class="keyword">short</span> pref_node_fork;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="keyword">int</span> numa_scan_seq;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> numa_scan_period;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> numa_scan_period_max;</span><br><span class="line">	<span class="keyword">int</span> numa_preferred_nid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numa_migrate_retry;</span><br><span class="line">	u64 node_stamp;			<span class="comment">/* migration stamp  */</span></span><br><span class="line">	u64 last_task_numa_placement;</span><br><span class="line">	u64 last_sum_exec_runtime;</span><br><span class="line">	<span class="keyword">struct</span> callback_head numa_work;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> list_head numa_entry;</span><br><span class="line">	<span class="keyword">struct</span> numa_group *numa_group;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * numa_faults is an array split into four regions:</span><br><span class="line">	 * faults_memory, faults_cpu, faults_memory_buffer, faults_cpu_buffer</span><br><span class="line">	 * in this precise order.</span><br><span class="line">	 *</span><br><span class="line">	 * faults_memory: Exponential decaying average of faults on a per-node</span><br><span class="line">	 * basis. Scheduling placement decisions are made based on these</span><br><span class="line">	 * counts. The values remain static for the duration of a PTE scan.</span><br><span class="line">	 * faults_cpu: Track the nodes the process was running on when a NUMA</span><br><span class="line">	 * hinting fault was incurred.</span><br><span class="line">	 * faults_memory_buffer and faults_cpu_buffer: Record faults per node</span><br><span class="line">	 * during the current scan window. When the scan completes, the counts</span><br><span class="line">	 * in faults_memory and faults_cpu decay and these values are copied.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *numa_faults;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> total_numa_faults;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * numa_faults_locality tracks if faults recorded during the last</span><br><span class="line">	 * scan window were remote/local or failed to migrate. The task scan</span><br><span class="line">	 * period is adapted based on the locality of the faults with different</span><br><span class="line">	 * weights depending on whether they were shared or private faults</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numa_faults_locality[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numa_pages_migrated;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* CONFIG_NUMA_BALANCING */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * cache last used pipe for splice</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> pipe_inode_info *splice_pipe;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> page_frag task_frag;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef	CONFIG_TASK_DELAY_ACCT</span></span><br><span class="line">	<span class="keyword">struct</span> task_delay_info *delays;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_FAULT_INJECTION</span></span><br><span class="line">	<span class="keyword">int</span> make_it_fail;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * when (nr_dirtied &gt;= nr_dirtied_pause), it's time to call</span><br><span class="line">	 * balance_dirty_pages() for some dirty throttling pause</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">int</span> nr_dirtied;</span><br><span class="line">	<span class="keyword">int</span> nr_dirtied_pause;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dirty_paused_when; <span class="comment">/* start of a write-and-pause period */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_LATENCYTOP</span></span><br><span class="line">	<span class="keyword">int</span> latency_record_count;</span><br><span class="line">	<span class="keyword">struct</span> latency_record latency_record[LT_SAVECOUNT];</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * time slack values; these are used to round up poll() and</span><br><span class="line">	 * select() etc timeout values. These are in nanoseconds.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timer_slack_ns;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> default_timer_slack_ns;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_KASAN</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> kasan_depth;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span></span><br><span class="line">	<span class="comment">/* Index of current stored address in ret_stack */</span></span><br><span class="line">	<span class="keyword">int</span> curr_ret_stack;</span><br><span class="line">	<span class="comment">/* Stack of return addresses for return function tracing */</span></span><br><span class="line">	<span class="keyword">struct</span> ftrace_ret_stack	*ret_stack;</span><br><span class="line">	<span class="comment">/* time stamp for last schedule */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ftrace_timestamp;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Number of functions that haven't been traced</span><br><span class="line">	 * because of depth overrun.</span><br><span class="line">	 */</span></span><br><span class="line">	atomic_t trace_overrun;</span><br><span class="line">	<span class="comment">/* Pause for the tracing */</span></span><br><span class="line">	atomic_t tracing_graph_pause;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_TRACING</span></span><br><span class="line">	<span class="comment">/* state flags for use by tracers */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> trace;</span><br><span class="line">	<span class="comment">/* bitmask and counter of trace recursion */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> trace_recursion;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* CONFIG_TRACING */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_MEMCG</span></span><br><span class="line">	<span class="keyword">struct</span> memcg_oom_info &#123;</span><br><span class="line">		<span class="keyword">struct</span> mem_cgroup *memcg;</span><br><span class="line">		gfp_t gfp_mask;</span><br><span class="line">		<span class="keyword">int</span> order;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> may_oom:<span class="number">1</span>;</span><br><span class="line">	&#125; memcg_oom;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_UPROBES</span></span><br><span class="line">	<span class="keyword">struct</span> uprobe_task *utask;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(CONFIG_BCACHE) || defined(CONFIG_BCACHE_MODULE)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	sequential_io;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	sequential_io_avg;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	task_state_change;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct task_struct，被放在 process 的 kernel stack 的最後，因此可以藉由 stack pointer 來取得 PCB，
不過在 2.6.22 以後已不用此方法。
當 PCB allocaed，Linux 會一併 allocate struct thead_info，thread_info 會被 push 至 stask 的 top，
而 thread_info 的第一個 member 則指向 task_struct。</p>
<p>x86
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">asm</span>/thread_info&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread_info &#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct	*task;		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="keyword">struct</span> exec_domain	*exec_domain;	<span class="comment">/* execution domain */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_preempt_count;</span><br><span class="line">	mm_segment_t		addr_limit;</span><br><span class="line">	<span class="keyword">void</span> __user		*sysenter_return;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uaccess_err:<span class="number">1</span>;	<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>x86
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">asm</span>/current.h&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef __ASSEMBLY__</span></span><br><span class="line"><span class="keyword">struct</span> task_struct;</span><br><span class="line"></span><br><span class="line">DECLARE_PER_CPU(<span class="keyword">struct</span> task_struct *, current_task);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">struct</span> task_struct *get_current(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> this_cpu_read_stable(current_task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> current get_current()</span></span><br></pre></td></tr></table></figure>
<p>每個 process 都有個 pid，type pid_t (int)
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure></p>
<p>可以知道最大的pid value</p>
<p>實際上 maximum pid 定義在
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;linux/threads.h&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * This controls the default maximum pid allocated to a process</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PID_MAX_DEFAULT (CONFIG_BASE_SMALL ? 0x1000 : 0x8000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * A maximum of 4 million PIDs should be enough for a while.</span><br><span class="line"> * [NOTE: PID/TIDs are limited to 2^29 ~= 500+ million, see futex.h.]</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PID_MAX_LIMIT (CONFIG_BASE_SMALL ? PAGE_SIZE * 8 : \</span></span><br><span class="line">	(<span class="keyword">sizeof</span>(<span class="keyword">long</span>) &gt; <span class="number">4</span> ? <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span> : PID_MAX_DEFAULT))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Define a minimum number of pids per cpu.  Heuristically based</span><br><span class="line"> * on original pid max of 32k for 32 cpus.  Also, increase the</span><br><span class="line"> * minimum settable value for pid_max on the running system based</span><br><span class="line"> * on similar defaults.  See kernel/pid.c:pidmap_init() for details.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PIDS_PER_CPU_DEFAULT	1024</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PIDS_PER_CPU_MIN	8</span></span><br></pre></td></tr></table></figure>
<h3 id="Process_State">Process State</h3><p>process state 定義在
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;linux/sched.h&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Task state bitmask. NOTE! These bits are also</span><br><span class="line"> * encoded in fs/proc/array.c: get_task_state().</span><br><span class="line"> *</span><br><span class="line"> * We have two separate sets of flags: task-&gt;state</span><br><span class="line"> * is about runnability, while task-&gt;exit_state are</span><br><span class="line"> * about the task exiting. Confusing, but this way</span><br><span class="line"> * modifying one set can't modify the other one by</span><br><span class="line"> * mistake.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_RUNNING		0</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_INTERRUPTIBLE	1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE	2</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __TASK_STOPPED		4</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __TASK_TRACED		8</span></span><br><span class="line"><span class="comment">/* in tsk-&gt;exit_state */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EXIT_DEAD		16</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EXIT_ZOMBIE		32</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EXIT_TRACE		(EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"><span class="comment">/* in tsk-&gt;state again */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_DEAD		64</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_WAKEKILL		128</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_WAKING		256</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_PARKED		512</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_STATE_MAX		1024</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_STATE_TO_CHAR_STR "RSDTtXZxKWP"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> ___assert_task_state[<span class="number">1</span> - <span class="number">2</span>*!!(</span><br><span class="line">		<span class="keyword">sizeof</span>(TASK_STATE_TO_CHAR_STR)-<span class="number">1</span> != ilog2(TASK_STATE_MAX)+<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of set_task_state */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_KILLABLE		(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_STOPPED		(TASK_WAKEKILL | __TASK_STOPPED)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_TRACED		(TASK_WAKEKILL | __TASK_TRACED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of wake_up */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_NORMAL		(TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_ALL		(TASK_NORMAL | __TASK_STOPPED | __TASK_TRACED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* get_task_state() */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_REPORT		(TASK_RUNNING | TASK_INTERRUPTIBLE | \</span></span><br><span class="line">				 TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \</span><br><span class="line">				 __TASK_TRACED | EXIT_ZOMBIE | EXIT_DEAD)</span><br></pre></td></tr></table></figure>
<p>struct task_struct-&gt;state</p>
<ul>
<li>TASK_RUNNING: The process is runnable, (running or watting to run)</li>
<li>TASK_INTERRUPTIBLE: The process is sleeping (blocking), wake up and become runnable if it receives a signal.</li>
<li>TASK_UNINTERRUPTIBLE: 與 TASK_INTERRUPTIBLE 很像，但他不會被因收到 signal 而變成 runnable</li>
<li>__TASK_TRACED: The process is being traced by another process, ex ptrace</li>
<li>__TASK_STOPPED: Process execution has stopped; the task is not running nor is it
eligible to run.This occurs if the task receives the SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU signal or if it receives
any signal while it is being debugged</li>
</ul>
<h3 id="Process_Context">Process Context</h3><p>process 是在 user-space 執行的，當呼叫到 system call，會進入 kernel-space，
此時 kernel 是在 process-context，current macro 會指到 呼叫 system call 的 process。</p>
<h3 id="Process_Creation">Process Creation</h3><p>Linux 藉由fork(), exec() 來完成 process 的 creation。
fork() 會 copy 一份 task_struct，更新 PID, PPID, 以及一些。
最後exec() 會載入 executable 至 address space然後執行。</p>
<h3 id="Copy-on-Write">Copy-on-Write</h3><h3 id="Forking">Forking</h3><p>fork(), 主要由 clone() system call 實作，clone() 則是呼叫 do_fork()。</p>
<p>linux/kernel/fork.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *  Ok, this is the main fork-routine.</span><br><span class="line"> *</span><br><span class="line"> * It copies the process, and if successful kick-starts</span><br><span class="line"> * it and waits for it to finish using the VM if required.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span><br><span class="line">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span><br><span class="line">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span><br><span class="line">	      <span class="keyword">int</span> __user *parent_tidptr,</span><br><span class="line">	      <span class="keyword">int</span> __user *child_tidptr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct *p;</span><br><span class="line">	<span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Determine whether and which event to report to ptracer.  When</span><br><span class="line">	 * called from kernel_thread or CLONE_UNTRACED is explicitly</span><br><span class="line">	 * requested, no event is reported; otherwise, report if the event</span><br><span class="line">	 * for the type of forking is enabled.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(clone_flags &amp; CLONE_UNTRACED)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">			trace = PTRACE_EVENT_VFORK;</span><br><span class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">((clone_flags &amp; CSIGNAL)</span> !</span>= SIGCHLD)</span><br><span class="line">			trace = PTRACE_EVENT_CLONE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			trace = PTRACE_EVENT_FORK;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!ptrace_event_enabled(current, trace)))</span><br><span class="line">			trace = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">			 child_tidptr, NULL, trace);</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Do this prior waking up the new thread - the thread pointer</span><br><span class="line">	 * might get invalid after that point, if the thread exits quickly.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">		<span class="keyword">struct</span> completion vfork;</span><br><span class="line">		<span class="keyword">struct</span> pid *pid;</span><br><span class="line"></span><br><span class="line">		trace_sched_process_fork(current, p);</span><br><span class="line"></span><br><span class="line">		pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">		nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">			put_user(nr, parent_tidptr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">			init_completion(&amp;vfork);</span><br><span class="line">			get_task_struct(p);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* forking complete and child started to run, tell ptracer */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(trace))</span><br><span class="line">			ptrace_event_pid(trace, pid);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">				ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		put_pid(pid);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		nr = PTR_ERR(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 do_fork() 中看到了 copy_process()，這裡開始產稱一個 process。
copy_process() 主要會作：</p>
<ol>
<li>calls dup_task_struct(), which creates a new kernel stack, thread_info, task_struct.
kernel stack 的大小為 THREAD_SIZE(2 * PAGE_SIZE)</li>
<li>確認新的 process 不會超出user 使用的 process 個數的限制，以及 resource的限制。</li>
<li>initialize task_struct 的 member。</li>
<li>把 process state 設為 TASK_UNINTERRUPTIBLE，確保不會被執行。(我找不到這段code)</li>
<li>update task_struct-&gt;flags</li>
<li><p>根據 clone() 的 flags 來決定哪些 resource 要 copy。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clear superuser privilege and worker flag */</span></span><br><span class="line">p-&gt;flags &amp;= ~(PF_SUPERPRIV | PF_WQ_WORKER);</span><br><span class="line"><span class="comment">/* 表示尚未 exec() */</span></span><br><span class="line">p-&gt;flags |= PF_FORKNOEXEC;</span><br></pre></td></tr></table></figure>
</li>
<li><p>return task_struct</p>
</li>
<li>calls alloc_pid()</li>
</ol>
<p>回到do_fork(), wake up new process and run。</p>
<h3 id="vfork:">vfork:</h3><ul>
<li><p>在copy_process()裡的copy_mm()，不會 copy task_struct-&gt;mm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">	atomic_inc(&amp;oldmm-&gt;mm_users);</span><br><span class="line">	mm = oldmm;</span><br><span class="line">	<span class="keyword">goto</span> good_mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>會assign vfork_done，</p>
</li>
<li>child 執行後，parent 會等待 vfork_done，直到 vfork_done completion，並送出 signal<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">		ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x86 asm/page_32_types.h</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> THREAD_SIZE_ORDER	1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> THREAD_SIZE		(PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x86_64 asm/page_64_types.h</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_KASAN</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> KASAN_STACK_ORDER 1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> KASAN_STACK_ORDER 0</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> THREAD_SIZE_ORDER	(2 + KASAN_STACK_ORDER)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CURRENT_MASK (~(THREAD_SIZE - 1))</span></span><br></pre></td></tr></table></figure>
<p>寫個 fork 程式來確認一下使用到的 參數
可以利用 strace 來 trace system call。
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clone</span>(child_stack=<span class="number">0</span>, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=<span class="number">0</span>x7<span class="built_in">fc</span>28d9089d0) = <span class="number">22146</span></span><br></pre></td></tr></table></figure></p>
<p>C library 的 fork 使用的是 clone()，
flags = CLONE_CHILD_CREARTID | CLONE_CHILD_SETTID | SIGCHILD</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/04/15/Process-Creation/" data-id="ciho8m29z000g43if275vd705" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2015/04/21/PER-CPU/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          PER_CPU
        
      </div>
    </a>
  
  
    <a href="/blog/2014/01/01/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Hello/">Hello</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C/">C</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Hello/">Hello</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux-Network-KVM/">Linux,Network,KVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux-qemu/">Linux,qemu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Network/">Network</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/C/" style="font-size: 20px;">C</a><a href="/blog/tags/Hello/" style="font-size: 10px;">Hello</a><a href="/blog/tags/Linux/" style="font-size: 20px;">Linux</a><a href="/blog/tags/Linux-Network-KVM/" style="font-size: 10px;">Linux,Network,KVM</a><a href="/blog/tags/Linux-qemu/" style="font-size: 10px;">Linux,qemu</a><a href="/blog/tags/Network/" style="font-size: 10px;">Network</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/06/">June 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/05/">May 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/04/">April 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/01/">January 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2015/09/24/qcow2-format/">qcow2 format</a>
          </li>
        
          <li>
            <a href="/blog/2015/09/22/Software-switches-in-Linux/">Software switches in Linux</a>
          </li>
        
          <li>
            <a href="/blog/2015/06/15/fPIC/">fPIC</a>
          </li>
        
          <li>
            <a href="/blog/2015/05/25/OSI-Model/">OSI Model</a>
          </li>
        
          <li>
            <a href="/blog/2015/04/30/Memory-Management/">Memory Management</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>