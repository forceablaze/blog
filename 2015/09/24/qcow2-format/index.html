<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>qcow2 format | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="QCOW2QEMU copy-on-write version 2
Wide range of features
Read only backing files
Snapshot (internal external)
supports multiple virtual machine snapshots through a new, flexible model for storing snap">
<meta property="og:type" content="article">
<meta property="og:title" content="qcow2 format">
<meta property="og:url" content="http://forceablaze.github.io/blog/2015/09/24/qcow2-format/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QCOW2QEMU copy-on-write version 2
Wide range of features
Read only backing files
Snapshot (internal external)
supports multiple virtual machine snapshots through a new, flexible model for storing snap">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qcow2 format">
<meta name="twitter:description" content="QCOW2QEMU copy-on-write version 2
Wide range of features
Read only backing files
Snapshot (internal external)
supports multiple virtual machine snapshots through a new, flexible model for storing snap">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://forceablaze.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-qcow2-format" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/09/24/qcow2-format/" class="article-date">
  <time datetime="2015-09-24T09:37:05.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      qcow2 format
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="QCOW2">QCOW2</h3><p>QEMU copy-on-write version 2</p>
<h5 id="Wide_range_of_features">Wide range of features</h5><ul>
<li>Read only backing files</li>
<li>Snapshot (internal external)<ul>
<li>supports multiple virtual machine snapshots through a new, flexible model for storing snapshots.</li>
</ul>
</li>
<li>Zero clusters partial allocation </li>
<li>Compression<ul>
<li>zlib</li>
</ul>
</li>
<li>Encryption<ul>
<li>128-bit AES-CBC</li>
</ul>
</li>
</ul>
<h5 id="Create_QCOW2_image">Create QCOW2 image</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img create <span class="operator">-f</span> qcow2 rico.qcow2 <span class="number">5</span>G</span><br><span class="line">$ qemu-info rico.qcow2</span><br><span class="line">image: rico.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="supported_options">supported options</h5><ul>
<li>compat</li>
<li>backing_file</li>
<li>backing_fmt</li>
<li>encryption</li>
<li>cluster_size</li>
<li>preallocation</li>
<li>lazy_refcounts</li>
<li>nocow</li>
</ul>
<h4 id="backing_file">backing file</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img create -b rico.qcow2 <span class="operator">-f</span> qcow2 rico-<span class="number">1</span>.qcow2</span><br><span class="line">$ qemu-img info</span><br><span class="line">image: rico-<span class="number">1</span>.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">backing file: rico.qcow2</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create backing based on rico-1.qcow2</span></span><br><span class="line">$ qemu-img create -b rico-<span class="number">1</span>.qcow2 <span class="operator">-f</span> qcow2 rico-<span class="number">1</span>A.qcow2</span><br><span class="line">$ qemu-img info --backing-chain rico-<span class="number">1</span>A.qcow2</span><br><span class="line">image: rico-<span class="number">1</span>A.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">backing file: rico-<span class="number">1</span>.qcow2</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">image: rico-<span class="number">1</span>.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">backing file: rico.qcow2</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">image: rico.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>Backing files are always opened <strong>read-only</strong>.</p>
<h4 id="example:">example:</h4><p>base &lt;- sn1 &lt;- sn2 &lt;- sn3 </p>
<p>現在要刪掉 sn2
有兩個方法 </p>
<ol>
<li><p>把 sn2 merge 到 sn1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-img commit sn2.qcow2</span><br><span class="line">qemu-img rebase -u -b sn1.qcow2 sn3.qcow2</span><br></pre></td></tr></table></figure>
</li>
<li><p>把 sn2 merge 到 sn3 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-img commit sn2.qcow2</span><br><span class="line">qemu-img rebase -u -b sn1.qcow2 sn3.qcow2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Shapshots">Shapshots</h4><ul>
<li>internal<ul>
<li>A type of snapshot, where a single QCOW2 file will hold both the ‘saved state’ and the ‘delta’ since that saved point. ‘Internal snapshots’ are very handy because it’s only a single file where all the snapshot info. is captured, and easy to copy/move around the machines.</li>
</ul>
</li>
<li>external (backing file)<ul>
<li>Here, the ‘original qcow2 file’ will be in a ‘read-only’ saved state, and the new qcow2 file(which will be generated once snapshot is created) will be the delta for the changes. So, all the changes will now be written to this delta file. ‘External Snapshots’ are useful for <strong>performing backups</strong>. Also, external snapshot creates a qcow2 file with the original file as its backing image, and the backing file can be /read/ in parallel with the running qemu.</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img snapshot -c snap1 rico-<span class="number">1</span>A.qcow2</span><br><span class="line">$ qemu-img snapshot -c snap2 rico-<span class="number">1</span>A.qcow2</span><br><span class="line">$ qemu-img snapshot <span class="operator">-l</span> rico-<span class="number">1</span>A.qcow2 </span><br><span class="line">Snapshot list:</span><br><span class="line">ID        TAG                 VM SIZE                DATE       VM CLOCK</span><br><span class="line"><span class="number">1</span>         snap1                     <span class="number">0</span> <span class="number">2015</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">58</span>:<span class="number">36</span>   <span class="number">00</span>:<span class="number">00</span>:<span class="number">00.000</span></span><br><span class="line"><span class="number">2</span>         snap2                     <span class="number">0</span> <span class="number">2015</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">59</span>:<span class="number">36</span>   <span class="number">00</span>:<span class="number">00</span>:<span class="number">00.000</span></span><br></pre></td></tr></table></figure>
<p><a href="https://kashyapc.fedorapeople.org/virt/lc-2012/snapshots-handout.html" target="_blank" rel="external">https://kashyapc.fedorapeople.org/virt/lc-2012/snapshots-handout.html</a>
<a href="http://wiki.qemu.org/Features/Snapshots" target="_blank" rel="external">http://wiki.qemu.org/Features/Snapshots</a>
<a href="http://wiki.qemu.org/Features/Snapshots2" target="_blank" rel="external">http://wiki.qemu.org/Features/Snapshots2</a></p>
<h3 id="General">General</h3><p>A qcow2 image file is organized in units of constant size, which are called (host) clusters. A cluster is the unit in which all allocations are done, both for actual guest data and for image metadata.</p>
<p>Likewise, the virtual disk as seen by the guest is divided into (guest) clusters of the same size.</p>
<p>All numbers in qcow2 are stored in Big Endian byte order.</p>
<h3 id="Header">Header</h3><p>the default value of qcow2
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAGIC (('Q' &lt;&lt; 24) | ('F' &lt;&lt; 16) | ('I' &lt;&lt; 8) | 0xfb)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_CRYPT_NONE 0</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_CRYPT_AES  1</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_CRYPT_CLUSTERS 32</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_SNAPSHOTS 65536</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8 MB refcount table is enough for 2 PB images at 64k cluster size</span><br><span class="line"> * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_REFTABLE_SIZE 0x800000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 32 MB L1 table is enough for 2 PB images at 64k cluster size</span><br><span class="line"> * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_L1_SIZE 0x2000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allow for an average of 1k per snapshot table entry, should be plenty of</span><br><span class="line"> * space for snapshot names and IDs */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_SNAPSHOTS_SIZE (1024 * QCOW_MAX_SNAPSHOTS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* indicate that the refcount of the referenced cluster is exactly one. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_OFLAG_COPIED     (1ULL &lt;&lt; 63)</span></span><br><span class="line"><span class="comment">/* indicate that the cluster is compressed (they never have the copied flag) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_OFLAG_COMPRESSED (1ULL &lt;&lt; 62)</span></span><br><span class="line"><span class="comment">/* The cluster reads as all zeros */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_OFLAG_ZERO (1ULL &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MIN_CLUSTER_BITS 9</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_CLUSTER_BITS 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Must be at least 2 to cover COW */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MIN_L2_CACHE_SIZE 2 /* clusters */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Must be at least 4 to cover all cases of refcount table growth */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MIN_REFCOUNT_CACHE_SIZE 4 /* clusters */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Whichever is more */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFAULT_L2_CACHE_CLUSTERS 8 /* clusters */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFAULT_L2_CACHE_BYTE_SIZE 1048576 /* bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The refblock cache needs only a fourth of the L2 cache size to cover as many</span><br><span class="line"> * clusters */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFAULT_L2_REFCOUNT_SIZE_RATIO 4</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFAULT_CLUSTER_SIZE 65536</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> QCowHeader &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> magic;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    uint64_t backing_file_offset;</span><br><span class="line">    <span class="keyword">uint32_t</span> backing_file_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cluster size = 1 &lt;&lt; cluster_bits</span><br><span class="line">     * 9 &lt;= cluster_bits &lt;= 21</span><br><span class="line">     * 512B &lt;= cluster size &lt;= 2M </span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cluster_bits;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* virtual disk size in bytes ex 100M = 0x0000000006400000 */</span></span><br><span class="line">    uint64_t size; <span class="comment">/* in bytes */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> crypt_method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of entries in the active L1 table (8 bytes) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> l1_size; <span class="comment">/* <span class="label">XXX: save number of clusters instead ? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Offset into the image file at which the active L1 table starts. Must be aligned to a cluster boundary. ex 0x0000000000030000 */</span></span><br><span class="line">    uint64_t l1_table_offset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Offset into the image file at which the refcount table starts. Must be aligned to a cluster boundary. ex 0x0000000000010000 */</span></span><br><span class="line">    uint64_t refcount_table_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of clusters that the refcount table occupies. initialized value = 1</span><br><span class="line">     * describes the size of the refcount table.</span><br><span class="line">     */</span></span><br><span class="line">    uint32_t refcount_table_clusters;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Max number of snapshots is 64K */</span></span><br><span class="line">    uint32_t nb_snapshots;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Offset into the image file at which the snapshot table starts. Must be aligned to a cluster boundary. zero if has no snapshot. */</span></span><br><span class="line">    uint64_t snapshots_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields are only valid for version &gt;= 3</span><br><span class="line">     * Bit 0: Dirty bit. If this bit is set then refcounts may be inconsistent, make sure to scan L1/L2 tables to repair refcounts before accessing the image.</span><br><span class="line">     * Bit 1: Corrupt bit. If this bit is set then any data structure may be corrupt and the image must not be written to (unless for regaining consistency).</span><br><span class="line">     */</span></span><br><span class="line">    uint64_t incompatible_features;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lazy refcounts bit. If this bit is set then lazy refcount updates can be used. This means marking the image file dirty and postponing refcount metadata updates. */</span></span><br><span class="line">    uint64_t compatible_features;</span><br><span class="line">    uint64_t autoclear_features;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Describes the width of a reference count block entry (width in bits: refcount_bits = 1 &lt;&lt; refcount_order). For version 2 images, the order is always assumed to be 4 (i.e. refcount_bits = 16). This value may not exceed 6 (i.e. refcount_bits = 64).</span><br><span class="line">     * refcount_order = 4 =&gt; refcount block entry size = 2 bytes</span><br><span class="line">     */</span></span><br><span class="line">    uint32_t refcount_order;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Length of the header structure in bytes. For version 2 images, the length is always assumed to be 72 bytes. version 3 is 104 bytes */</span></span><br><span class="line">    uint32_t header_length;</span><br><span class="line">&#125; QEMU_PACKED QCowHeader;</span></span><br></pre></td></tr></table></figure>
<h3 id="Header_Extension">Header Extension</h3><p><strong>Directly after the image header</strong>, optional sections called header extensions can be stored. Each extension has a structure like the following:
Byte</p>
<ul>
<li>0-3: Header extension type:<ul>
<li>0x00000000  - End of the header extension area</li>
<li>0xE2792ACA - Backing file format name</li>
<li>0x6803F857 - Feature name table</li>
<li>other            - Unknown header extension, can be safely ignored</li>
</ul>
</li>
<li>4-7: Length of the header extension data.</li>
<li>8-n: Header extension data.</li>
<li>n-m: Padding to round up the header extension size to the next multiple of 8.</li>
</ul>
<p>defined in block/qcow2.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> magic;</span><br><span class="line">    <span class="keyword">uint32_t</span> len;</span><br><span class="line">&#125; QEMU_PACKED QCowExtension;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  QCOW2_EXT_MAGIC_END 0</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  QCOW2_EXT_MAGIC_BACKING_FORMAT 0xE2792ACA</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  QCOW2_EXT_MAGIC_FEATURE_TABLE 0x6803f857</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Backing_file">Backing file</h4><p>0xE2792ACA,00000005,71636F77,32000000</p>
<p>the header extension data is 0x71636F7732 = &#39;q&#39;, &#39; c&#39;, &#39;o&#39;, &#39;w&#39;, &#39;2&#39;.</p>
<p>If the image has a backing file then the backing file name should be stored in the remaining space <strong>between the end of the headers extension area and the end of the first cluster</strong>. It is not allowed to store other data here, so that an implementation can safely modify the header and add extensions without harming data of compatible features that is doesn&#39;t support. Compatible features that need space for additional data can use a header extension.</p>
<h4 id="Feature_name_table">Feature name table</h4><p>The feature name table is an optional header extension that contains the name for features used by the image. It can be used by applications that don&#39;t know the respective feature (e.g. because the feature was introduced only later) to display a useful error message.</p>
<p>defined in block/qcow2.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Qcow2Feature &#123;</span><br><span class="line">    <span class="comment">/* Type of feature (select feature bitmap)</span><br><span class="line">     *    0: Incompatible feature</span><br><span class="line">     *    1: Compatible feature</span><br><span class="line">     *    2: Autoclear feature</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Bit number within the selected feature bitmap (valid values: 0-63) */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bit;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Feature name (padded with zeros, but not necessarily null terminated if it has full length) */</span></span><br><span class="line">    <span class="keyword">char</span>    name[<span class="number">46</span>];</span><br><span class="line">&#125; QEMU_PACKED Qcow2Feature;</span><br></pre></td></tr></table></figure></p>
<p><strong>the size of feature is 0x30 bytes</strong>.</p>
<p>0x6803F857,00000090, 00006469....(multiple feature table)</p>
<p>the feature that length 144 bytes = 48 / 3 = 3 feature</p>
<ul>
<li>dirty bit feature
0x00,00, 0x646972747920626974 (&quot;dirty bit&quot;) 000000...</li>
<li>corrupt bit feature
0x00,01 0x636F727275707420626974 (&quot;corrupt bit&quot;) 000000...</li>
<li>lazy refcounts feature
0x01,00 0x6C617A7920726566636F756E7473 (&quot;lazy refcounts&quot;) 000000.... </li>
</ul>
<h4 id="End_of_the_header_extension_area">End of the header extension area</h4><ul>
<li>end of the header type, data length is zero.
0x00000000,00000000</li>
</ul>
<h3 id="Host_Cluster_Management">Host Cluster Management</h3><p>qcow2 manages the allocation of host clusters by maintaining a refernce count for each host cluster. <strong>A refcount of 0 means that the cluster is free, 1 means that it is used, and &gt;= 2 means that it is used and any write access must perform a COW</strong> (copy on write) operation.</p>
<p>The refcounts are managed in a <strong>two-level table</strong>. The first level is called <strong>refcount table</strong> and has a variable size (which is stored in the header). The refcount table can cover multiple clusters, however it needs to be contiguous in the image file.</p>
<p><strong>It contains pointers to the second level structures which are called refcount blocks</strong> and are exactly <strong>one clusters in size</strong>.</p>
<p>Given a offset into the image file, the refcount of its cluster can be obtained as follows:</p>
<blockquote>
<p>refcount_block_entries = (cluster_size * 8 / refcount_bits)</p>
<p>refcount_block_index = (offset / cluster_size) % refcount_block_entires
refcount_table_index = (offset / cluster_size) / refcount_block_entires</p>
<p>refcount_block = load_cluster(refcount_table[refcount_table_index])
return refcount_block[refcount_block_index];</p>
</blockquote>
<p>cluster_size = 64K
refcount_order = 4 -&gt; refcount_bits = 16
=&gt; the size of a refcount block is 64K * 8 / 16 = 0x8000 = 32K</p>
<blockquote>
<pre><code>Given image offset <span class="number">0</span>x20000
<span class="variable">refcount_block_entries =</span> <span class="number">32</span>KB
<span class="variable">refcount_block_index =</span> <span class="number">0</span>x20000 / <span class="number">64</span>K % <span class="number">32</span><span class="variable">K =</span> <span class="number">0</span>
<span class="variable">refcount_table_index =</span> <span class="number">0</span>x20000 / <span class="number">64</span>K / <span class="number">32</span><span class="variable">K =</span> <span class="number">0</span>


Given image offset <span class="number">0</span>x7FE00
<span class="variable">refcount_block_entries =</span> <span class="number">32</span>KB
<span class="variable">refcount_block_index =</span> <span class="number">0</span>x7FE00 / <span class="number">64</span>K % <span class="number">32</span><span class="variable">K =</span> <span class="number">7</span>
<span class="variable">refcount_table_index =</span> <span class="number">0</span>x7FE00 / <span class="number">64</span>K / <span class="number">32</span><span class="variable">K =</span> <span class="number">0</span>
</code></pre></blockquote>
<p>a refcount table can handle 64K * 32KB data</p>
<p><strong>L2 table size = cluster_size / 8</strong>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">    s-&gt;l2_bits = s-&gt;cluster_bits - 3; /* L2 is always one cluster */</span><br><span class="line">    s-&gt;l2_size = 1 &lt;&lt; s-&gt;l2_bits;</span><br><span class="line">    /* 2^(s-&gt;refcount_order - 3) is the refcount width in bytes */</span><br><span class="line">    s-&gt;refcount_block_bits = s-&gt;cluster_bits - (s-&gt;refcount_order - 3);</span><br><span class="line">    s-&gt;refcount_block_size = 1 &lt;&lt; s-&gt;refcount_block_bits;</span><br><span class="line">    bs-&gt;total_sectors = header.size / 512;</span><br><span class="line">    s-&gt;csize_shift = (62 - (s-&gt;cluster_bits - 8));</span><br><span class="line">    s-&gt;csize_mask = (1 &lt;&lt; (s-&gt;cluster_bits - 8)) - 1;</span><br><span class="line">    s-&gt;cluster_offset_mask = (1LL &lt;&lt; s-&gt;csize_shift) - 1;</span><br><span class="line"></span><br><span class="line">    s-&gt;refcount_table_offset = header.refcount_table_offset;</span><br><span class="line">    s-&gt;refcount_table_size =</span><br><span class="line">        header.refcount_table_clusters &lt;&lt; (s-&gt;cluster_bits - 3);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; if **refcount_order = 4, cluster_bits = 16, refcount_table_clusters = 1**</span><br><span class="line">&gt; refcount_block_bits = 16 - (4 - 3) = 15</span><br><span class="line">&gt; refcount_block_size = 1 &lt;&lt; 15 = 32KB</span><br><span class="line">&gt; refcount_table_size = 1 &lt;&lt; 13 = 8KB</span><br><span class="line">&gt; 8KB / 8B = 1K refcount table entry</span><br><span class="line"></span><br><span class="line">#### Refcount table entry (8 bytes)</span><br><span class="line">BIt</span><br><span class="line"></span><br><span class="line"> - 0-8</span><br><span class="line">Reserved (set to 0)</span><br><span class="line"> - 9-63</span><br><span class="line"> Bits 9-63 of **the offset into the image file at which the refcount block starts.** Must be aligned to a cluster boundary.</span><br><span class="line"> If this is 0, the corresponding refcount block has not yet been allocated. All refcounts managed by this refcount block are 0.</span><br><span class="line"></span><br><span class="line">ex:</span><br><span class="line"></span><br><span class="line">&gt; refcount table at offset 0x10000</span><br><span class="line">&gt; 0x0000, 000000020000 =&gt; offset 0x20000</span><br><span class="line"></span><br><span class="line">#### Refcount block entry ( width = refcount_bit )</span><br><span class="line">Bit</span><br><span class="line"></span><br><span class="line"> - 0-x (x = refcount_bits - 1)</span><br><span class="line">**Reference count of the cluster**. If refcount_bits implies a sub-type width, note that bit 0 means the least significant bit in this context.</span><br><span class="line"></span><br><span class="line">ex:</span><br><span class="line"></span><br><span class="line">&gt; refcount_order = 4 =&gt; refcount_bit = 16, block entry size is 2 bytes</span><br><span class="line">&gt; 0x0001, 0001, 0001, 0001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Cluster mapping</span><br><span class="line">Just as for refcounts, qcow2 use **a two-level structure for the mapping of guest clusters to host clusters**. They are called L1 and L2 table.</span><br><span class="line">The L1 table has a variable size (stored in the header) and may use multiple clusters, however it must be contiguous in the image file. L2 tables are exactly one cluster in size.</span><br><span class="line"></span><br><span class="line">Given a offset into the virtual disk, the offset into the image file can be obtained as follows:</span><br><span class="line"></span><br><span class="line">&gt; l2_entries = (cluster_size / sizeof(uint64_t) )</span><br><span class="line">&gt; </span><br><span class="line">&gt; l2_index = (offset / cluster_size) % l2_entries</span><br><span class="line">&gt; l1_index = (offset / cluster_size) / l2_entries</span><br><span class="line">&gt; </span><br><span class="line">&gt; l2_table = load_cluster(l1_table[l1_index]);</span><br><span class="line">&gt; cluster_offset = l2_table[l2_index];</span><br><span class="line">&gt; </span><br><span class="line">&gt; return cluster_offset + (offset % cluster_size)</span><br><span class="line"></span><br><span class="line">if  virtual disk offset = 1M, cluster_size = 64K</span><br><span class="line">&gt; l2_entries = cluster_size / 8 = 8KB</span><br><span class="line">&gt; **l2_index = 16 % 8K = 16**</span><br><span class="line">&gt; l1_index = 16 / 8K = 0</span><br><span class="line">&gt; **a L1 entry can handle 8K * 64KB =  512MB data**</span><br><span class="line">&gt; get the 16'd L2 entry in L2 table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if  virtual disk offset = 99M - 512, cluster_size = 64K</span><br><span class="line">&gt; l2_entries = cluster_size / 8 = 8KB</span><br><span class="line">&gt; **l2_index = 1583 % 8K = 1583**</span><br><span class="line">&gt; l1_index = 1583 / 8K = 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1. get the 1583'd L2 entry in L2 table</span><br><span class="line">&gt; 2. get cluster_offset from L2 entry</span><br><span class="line">&gt; 3. 0x70000 + (0xFE00) = 0x7FE00</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### L1 table entry (8 bytes)</span><br><span class="line">Bit</span><br><span class="line"></span><br><span class="line"> - 0-8:</span><br><span class="line">Reserved (set to 0)  ????</span><br><span class="line"> - 9-55:</span><br><span class="line">Bits 9-55 of **the offset into the image file at which the L2 table start**. Must be aligned to a cluster boundary. If the offset is 0, the L2 table and all clusters described by this L2 table are unallocated.</span><br><span class="line"> - 56-62:</span><br><span class="line">Reserved (set to 0)</span><br><span class="line"> - 63:</span><br><span class="line">0 for an L2 table that is **unused or requires COW**, 1 if its refcount is exactly one. This information is only accurate in the active L1 table.</span><br><span class="line"></span><br><span class="line">&gt; Given L1 table offset is 0x30000</span><br><span class="line">&gt; 0x80, 00000000040000</span><br><span class="line">&gt; L2 offset = 0x40000</span><br><span class="line"></span><br><span class="line">#### L2 table entry (8 bytes)</span><br><span class="line"></span><br><span class="line">Bit</span><br><span class="line"></span><br><span class="line"> - 0-61:</span><br><span class="line">Cluster descriptor</span><br><span class="line"> - 62:</span><br><span class="line">0 for standard clusters</span><br><span class="line">1 for compressed clusters</span><br><span class="line"> - 63:</span><br><span class="line">0 for a cluster that is **unused or requires COW**, 1 if its refcount is exactly one. This information is only accurate in L2 tables that are reachable form the active L1 table.</span><br><span class="line"></span><br><span class="line">&gt; a L2 table entry at 0x40000</span><br><span class="line">&gt; 10000000B,  0x00000000050000</span><br><span class="line"></span><br><span class="line">#### Standard Cluster Descriptor (62 bits)</span><br><span class="line"></span><br><span class="line">BIt</span><br><span class="line"></span><br><span class="line"> - 0:</span><br><span class="line">If set to 1, the cluster reads as all zeros. The host cluster offset can be used to describe a preallocation, but it won't be used for reading data from this cluster, nor is data read from the backing file if the cluster is unallocated.</span><br><span class="line"> - 1-8:</span><br><span class="line">Reserved (set to 0)</span><br><span class="line"> - 9-55:</span><br><span class="line">Bits 9-55 of host cluster offset. Must be aligned to a cluster boundary. If the offset is 0, the cluster is unallocated.</span><br><span class="line"> - 56-61:</span><br><span class="line">Reserved (set to 0)</span><br><span class="line"></span><br><span class="line">&gt; bit 0-55</span><br><span class="line">&gt; 0x00000000050000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Compressed Clusters</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Snapshots</span><br><span class="line"></span><br><span class="line">qcow2 supports internal snapshots. Their basic principle of operation is **to switch the active L1 table**, so that a different set of host clusters are exposed to the guest.</span><br><span class="line"></span><br><span class="line">When creating a snapshot, the L1 table should be copied and **the refcount of all L2 tables and clusters reachable from this L1 table must be increased**, so that **a write causes a COW** and isn't visible in other snapshots.</span><br><span class="line"></span><br><span class="line">When loading a snapshot, bit 63 of all entries in the new active L1 table and all L2 tables referenced by it **must be reconstructed** from the refcount table as it doesn't need to be accurate in inactive L1 tables.</span><br><span class="line"></span><br><span class="line">A directory of all snapshots is **stored in the snapshot table**, a contiguous area in the image file, whose starting **offset and length are given by the header** fields snapshots_offset and nb_snapshot. The entries of the snapshot table have variable length, depending on the length of ID, name and extra data.</span><br><span class="line"></span><br><span class="line">``` c</span><br><span class="line">typedef struct QEMU_PACKED QCowSnapshotHeader &#123;</span><br><span class="line">    /* header is 8 byte aligned */</span><br><span class="line">    uint64_t l1_table_offset;</span><br><span class="line"></span><br><span class="line">    uint32_t l1_size;</span><br><span class="line">    uint16_t id_str_size;</span><br><span class="line">    uint16_t name_size;</span><br><span class="line"></span><br><span class="line">    uint32_t date_sec;</span><br><span class="line">    uint32_t date_nsec;</span><br><span class="line"></span><br><span class="line">    uint64_t vm_clock_nsec;</span><br><span class="line"></span><br><span class="line">    uint32_t vm_state_size;</span><br><span class="line">    uint32_t extra_data_size; /* for extension */</span><br><span class="line">    /* extra data follows */</span><br><span class="line">    /* id_str follows */</span><br><span class="line">    /* name follows  */</span><br><span class="line">&#125; QCowSnapshotHeader;</span><br></pre></td></tr></table></figure></p>
<h3 id="QEMU_Cache">QEMU Cache</h3><p>default cache size is 1M</p>
<p>cache mode</p>
<ul>
<li>none<ul>
<li>host do not do cache, guest disk cache is wb. </li>
</ul>
</li>
<li>writeback<ul>
<li>host do read/write cache, guest disk cache is writeback</li>
</ul>
</li>
<li>writethrough<ul>
<li>host do read cache, guest disk cache is writethrough.</li>
</ul>
</li>
<li>unsafe<ul>
<li>host do not flush cache, guest disk cache is writeback</li>
</ul>
</li>
<li>directsync<ul>
<li>host do not do cache, guest disk cache is writethrough<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Set open flags for a given cache mode</span><br><span class="line"> *</span><br><span class="line"> * Return 0 on success, -1 if the cache mode was invalid.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * BDRV_O_NOCACHE: host end 繞過 cache</span><br><span class="line"> * BDRV_O_CACHE_WB: guest 啟用 writeback cache</span><br><span class="line"> * BDRV_O_NO_FLUSH: host end 不同步 cache</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bdrv_parse_cache_flags</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">int</span> *flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    *flags &amp;= ~BDRV_O_CACHE_MASK;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(mode, <span class="string">"off"</span>) || !<span class="built_in">strcmp</span>(mode, <span class="string">"none"</span>)) &#123;</span><br><span class="line">        *flags |= BDRV_O_NOCACHE | BDRV_O_CACHE_WB;</span><br><span class="line">        <span class="comment">// host no cache, guest has wb cache</span></span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(!<span class="built_in">strcmp</span>(mode, "directsync")</span>) </span>&#123;</span><br><span class="line">        *flags |= BDRV_O_NOCACHE;</span><br><span class="line">        <span class="comment">// host and guest no cache</span></span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(!<span class="built_in">strcmp</span>(mode, "writeback")</span>) </span>&#123;</span><br><span class="line">        *flags |= BDRV_O_CACHE_WB;</span><br><span class="line">        <span class="comment">// host and guest has wb cache</span></span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(!<span class="built_in">strcmp</span>(mode, "unsafe")</span>) </span>&#123;</span><br><span class="line">        *flags |= BDRV_O_CACHE_WB;</span><br><span class="line">        *flags |= BDRV_O_NO_FLUSH;</span><br><span class="line">        <span class="comment">// host 不 flush cache, guest 有 cache</span></span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(!<span class="built_in">strcmp</span>(mode, "writethrough")</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* this is the default */</span></span><br><span class="line">        <span class="comment">// host 有 cache, guest 沒有</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="LVM_+_qcow2">LVM + qcow2</h4><p> Thin Provision
<a href="http://mathslinux.org/?p=379" target="_blank" rel="external">http://mathslinux.org/?p=379</a></p>
<h3 id="Snapshot">Snapshot</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> QEMU_PACKED QCowSnapshotHeader &#123;</span><br><span class="line">    <span class="comment">/* header is 8 byte aligned */</span></span><br><span class="line">    uint64_t l1_table_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> l1_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> id_str_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> name_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> date_sec;</span><br><span class="line">    <span class="keyword">uint32_t</span> date_nsec;</span><br><span class="line"></span><br><span class="line">    uint64_t vm_clock_nsec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_state_size;</span><br><span class="line">    <span class="keyword">uint32_t</span> extra_data_size; <span class="comment">/* for extension */</span></span><br><span class="line">    <span class="comment">/* extra data follows */</span></span><br><span class="line">    <span class="comment">/* id_str follows */</span></span><br><span class="line">    <span class="comment">/* name follows  */</span></span><br><span class="line">&#125; QCowSnapshotHeader;</span><br></pre></td></tr></table></figure>
<h3 id="QEMUFile">QEMUFile</h3><p>defined in migration/qemu-file-internal.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> QEMUFile &#123;</span><br><span class="line">    <span class="keyword">const</span> QEMUFileOps *ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* assign BlockDriverState */</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> bytes_xfer;</span><br><span class="line">    <span class="keyword">int64_t</span> xfer_limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> pos; <span class="comment">/* start of buffer when writing, end of buffer</span><br><span class="line">                    when reading */</span></span><br><span class="line">    <span class="keyword">int</span> buf_index;</span><br><span class="line">    <span class="keyword">int</span> buf_size; <span class="comment">/* 0 when writing */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> buf[IO_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> iovec iov[MAX_IOV_SIZE];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> iovcnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last_error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>defined in migration/savevm.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* savevm/loadvm support */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">block_writev_buffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt,</span><br><span class="line">                                   <span class="keyword">int64_t</span> pos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    QEMUIOVector qiov;</span><br><span class="line"></span><br><span class="line">    qemu_iovec_init_external(&amp;qiov, iov, iovcnt);</span><br><span class="line">    ret = bdrv_writev_vmstate(opaque, &amp;qiov, pos);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qiov.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">block_put_buffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf,</span><br><span class="line">                                <span class="keyword">int64_t</span> pos, size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    bdrv_save_vmstate(opaque, buf, pos, size);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">block_get_buffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int64_t</span> pos,</span><br><span class="line">                                size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bdrv_load_vmstate(opaque, buf, pos, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bdrv_fclose</span><span class="params">(<span class="keyword">void</span> *opaque)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bdrv_flush(opaque);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> QEMUFileOps bdrv_read_ops = &#123;</span><br><span class="line">    .get_buffer = block_get_buffer,</span><br><span class="line">    .close =      bdrv_fclose</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> QEMUFileOps bdrv_write_ops = &#123;</span><br><span class="line">    .put_buffer     = block_put_buffer,</span><br><span class="line">    .writev_buffer  = block_writev_buffer,</span><br><span class="line">    .close          = bdrv_fclose</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QEMUFile *qemu_fopen_bdrv(BlockDriverState *bs, <span class="keyword">int</span> is_writable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_writable) &#123;</span><br><span class="line">        <span class="keyword">return</span> qemu_fopen_ops(bs, &amp;bdrv_write_ops);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qemu_fopen_ops(bs, &amp;bdrv_read_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>defined in block/block_int.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> BlockDriverState &#123;</span><br><span class="line">    <span class="keyword">int64_t</span> total_sectors; <span class="comment">/* if we are reading a disk image, give its</span><br><span class="line">                              size in sectors */</span></span><br><span class="line">    <span class="keyword">int</span> read_only; <span class="comment">/* if true, the media is read only */</span></span><br><span class="line">    <span class="keyword">int</span> open_flags; <span class="comment">/* flags used to open the file, re-used for re-open */</span></span><br><span class="line">    <span class="keyword">int</span> encrypted; <span class="comment">/* if true, the media is encrypted */</span></span><br><span class="line">    <span class="keyword">int</span> valid_key; <span class="comment">/* if true, a valid encryption key has been set */</span></span><br><span class="line">    <span class="keyword">int</span> sg;        <span class="comment">/* if true, the device is a /dev/sg* */</span></span><br><span class="line">    <span class="keyword">int</span> copy_on_read; <span class="comment">/* if true, copy read backing sectors into image</span><br><span class="line">                         note this is a reference count */</span></span><br><span class="line">    <span class="keyword">bool</span> probed;</span><br><span class="line"></span><br><span class="line">    BlockDriver *drv; <span class="comment">/* NULL means no media */</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    BlockBackend *blk;          <span class="comment">/* owning backend, if any */</span></span><br><span class="line"></span><br><span class="line">    AioContext *aio_context; <span class="comment">/* event loop used for fd handlers, timers, etc */</span></span><br><span class="line">    <span class="comment">/* long-running tasks intended to always use the same AioContext as this</span><br><span class="line">     * BDS may register themselves in this list to be notified of changes</span><br><span class="line">     * regarding this BDS's context */</span></span><br><span class="line">    QLIST_HEAD(, BdrvAioNotifier) aio_notifiers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> filename[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> backing_file[PATH_MAX]; <span class="comment">/* if non zero, the image is a diff of</span><br><span class="line">                                    this file image */</span></span><br><span class="line">    <span class="keyword">char</span> backing_format[<span class="number">16</span>]; <span class="comment">/* if non-zero and backing_file exists */</span></span><br><span class="line"></span><br><span class="line">    QDict *full_open_options;</span><br><span class="line">    <span class="keyword">char</span> exact_filename[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    BlockDriverState *backing_hd;</span><br><span class="line">    BdrvChild *backing_child;</span><br><span class="line">    BlockDriverState *file;</span><br><span class="line"></span><br><span class="line">    NotifierList close_notifiers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Callback before write request is processed */</span></span><br><span class="line">    NotifierWithReturnList before_write_notifiers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* number of in-flight serialising requests */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> serialising_in_flight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I/O throttling */</span></span><br><span class="line">    CoQueue      throttled_reqs[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">bool</span>         io_limits_enabled;</span><br><span class="line">    <span class="comment">/* The following fields are protected by the ThrottleGroup lock.</span><br><span class="line">     * See the ThrottleGroup documentation for details. */</span></span><br><span class="line">    ThrottleState *throttle_state;</span><br><span class="line">    ThrottleTimers throttle_timers;</span><br><span class="line">    <span class="keyword">unsigned</span>       pending_reqs[<span class="number">2</span>];</span><br><span class="line">    QLIST_ENTRY(BlockDriverState) round_robin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I/O stats (display with "info blockstats"). */</span></span><br><span class="line">    BlockAcctStats stats;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I/O Limits */</span></span><br><span class="line">    BlockLimits bl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whether produces zeros when read beyond eof */</span></span><br><span class="line">    <span class="keyword">bool</span> zero_beyond_eof;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Alignment requirement for offset/length of I/O requests */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> request_alignment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the block size for which the guest device expects atomicity */</span></span><br><span class="line">    <span class="keyword">int</span> guest_block_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do we need to tell the quest if we have a volatile write cache? */</span></span><br><span class="line">    <span class="keyword">int</span> enable_write_cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NOTE: the following infos are only hints for real hardware</span><br><span class="line">       drivers. They are not used by the block driver */</span></span><br><span class="line">    BlockdevOnError on_read_error, on_write_error;</span><br><span class="line">    <span class="keyword">bool</span> iostatus_enabled;</span><br><span class="line">    BlockDeviceIoStatus iostatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the following member gives a name to every node on the bs graph. */</span></span><br><span class="line">    <span class="keyword">char</span> node_name[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">/* element of the list of named nodes building the graph */</span></span><br><span class="line">    QTAILQ_ENTRY(BlockDriverState) node_list;</span><br><span class="line">    <span class="comment">/* element of the list of "drives" the guest sees */</span></span><br><span class="line">    QTAILQ_ENTRY(BlockDriverState) device_list;</span><br><span class="line">    QLIST_HEAD(, BdrvDirtyBitmap) dirty_bitmaps;</span><br><span class="line">    <span class="keyword">int</span> refcnt;</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, BdrvTrackedRequest) tracked_requests;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* operation blockers */</span></span><br><span class="line">    QLIST_HEAD(, BdrvOpBlocker) op_blockers[BLOCK_OP_TYPE_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* long-running background operation */</span></span><br><span class="line">    BlockJob *job;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The node that this node inherited default options from (and a reopen on</span><br><span class="line">     * which can affect this node by changing these defaults). This is always a</span><br><span class="line">     * parent node of this node. */</span></span><br><span class="line">    BlockDriverState *inherits_from;</span><br><span class="line">    QLIST_HEAD(, BdrvChild) children;</span><br><span class="line"></span><br><span class="line">    QDict *options;</span><br><span class="line">    BlockdevDetectZeroesOptions detect_zeroes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The error object in use for blocking operations on backing_hd */</span></span><br><span class="line">    Error *backing_blocker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* threshold limit for writes, in bytes. "High water mark". */</span></span><br><span class="line">    uint64_t write_threshold_offset;</span><br><span class="line">    NotifierWithReturn write_threshold_notifier;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="SaveState">SaveState</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SaveVMHandlers &#123;</span><br><span class="line">    <span class="comment">/* This runs inside the iothread lock.  */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_params)(<span class="keyword">const</span> MigrationParams *params, <span class="keyword">void</span> * opaque);</span><br><span class="line">    SaveStateHandler *save_state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*cancel)(<span class="keyword">void</span> *opaque);</span><br><span class="line">    <span class="keyword">int</span> (*save_live_complete)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This runs both outside and inside the iothread lock.  */</span></span><br><span class="line">    <span class="keyword">bool</span> (*is_active)(<span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This runs outside the iothread lock in the migration case, and</span><br><span class="line">     * within the lock in the savevm case.  The callback had better only</span><br><span class="line">     * use data that is local to the migration thread or protected</span><br><span class="line">     * by other locks.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*save_live_iterate)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This runs outside the iothread lock!  */</span></span><br><span class="line">    <span class="keyword">int</span> (*save_live_setup)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line">    uint64_t (*save_live_pending)(QEMUFile *f, <span class="keyword">void</span> *opaque, uint64_t max_size);</span><br><span class="line"></span><br><span class="line">    LoadStateHandler *load_state;</span><br><span class="line">&#125; SaveVMHandlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SaveStateEntry &#123;</span><br><span class="line">    QTAILQ_ENTRY(SaveStateEntry) entry;</span><br><span class="line">    <span class="keyword">char</span> idstr[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> instance_id;</span><br><span class="line">    <span class="keyword">int</span> alias_id;</span><br><span class="line">    <span class="keyword">int</span> version_id;</span><br><span class="line">    <span class="keyword">int</span> section_id;</span><br><span class="line">    SaveVMHandlers *ops;</span><br><span class="line">    <span class="keyword">const</span> VMStateDescription *vmsd;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    CompatEntry *compat;</span><br><span class="line">    <span class="keyword">int</span> is_ram;</span><br><span class="line">&#125; SaveStateEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SaveState &#123;</span><br><span class="line">    QTAILQ_HEAD(, SaveStateEntry) handlers;</span><br><span class="line">    <span class="keyword">int</span> global_section_id;</span><br><span class="line">    <span class="keyword">bool</span> skip_configuration;</span><br><span class="line">    <span class="keyword">uint32_t</span> len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">&#125; SaveState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> SaveState savevm_state = &#123;</span><br><span class="line">    .handlers = QTAILQ_HEAD_INITIALIZER(savevm_state.handlers),</span><br><span class="line">    .global_section_id = <span class="number">0</span>,</span><br><span class="line">    .skip_configuration = <span class="keyword">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>register handlers
register_savevm()</p>
<h3 id="VMState">VMState</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int64_t</span> <span class="title">size_to_l1</span><span class="params">(BDRVQcow2State *s, <span class="keyword">int64_t</span> size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shift = s-&gt;cluster_bits + s-&gt;l2_bits;</span><br><span class="line">    <span class="keyword">return</span> (size + (<span class="number">1U</span>LL &lt;&lt; shift) - <span class="number">1</span>) &gt;&gt; shift;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int64_t</span> <span class="title">qcow2_vm_state_offset</span><span class="params">(BDRVQcow2State *s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int64_t</span>)s-&gt;l1_vm_state_index &lt;&lt; (s-&gt;cluster_bits + s-&gt;l2_bits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s-&gt;l1_vm_state_index = size_to_l1(s, header.size);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>VM state save at qcow2_vm_state_offset()
=1 &lt;&lt; 29 = 0x20000000 = 512M</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/09/24/qcow2-format/" data-id="ciho8m29j000143ifn4sk2dru" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Linux-qemu/">Linux,qemu</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2015/09/22/Software-switches-in-Linux/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Software switches in Linux</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Hello/">Hello</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C/">C</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Hello/">Hello</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux-Network-KVM/">Linux,Network,KVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux-qemu/">Linux,qemu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Network/">Network</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/C/" style="font-size: 20px;">C</a><a href="/blog/tags/Hello/" style="font-size: 10px;">Hello</a><a href="/blog/tags/Linux/" style="font-size: 20px;">Linux</a><a href="/blog/tags/Linux-Network-KVM/" style="font-size: 10px;">Linux,Network,KVM</a><a href="/blog/tags/Linux-qemu/" style="font-size: 10px;">Linux,qemu</a><a href="/blog/tags/Network/" style="font-size: 10px;">Network</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/06/">June 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/05/">May 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/04/">April 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/01/">January 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2015/09/24/qcow2-format/">qcow2 format</a>
          </li>
        
          <li>
            <a href="/blog/2015/09/22/Software-switches-in-Linux/">Software switches in Linux</a>
          </li>
        
          <li>
            <a href="/blog/2015/06/15/fPIC/">fPIC</a>
          </li>
        
          <li>
            <a href="/blog/2015/05/25/OSI-Model/">OSI Model</a>
          </li>
        
          <li>
            <a href="/blog/2015/04/30/Memory-Management/">Memory Management</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>