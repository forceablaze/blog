<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://forceablaze.github.io/blog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://forceablaze.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-qcow2-format" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/09/24/qcow2-format/" class="article-date">
  <time datetime="2015-09-24T09:37:05.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/09/24/qcow2-format/">qcow2 format</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="QCOW2">QCOW2</h3><p>QEMU copy-on-write version 2</p>
<h5 id="Wide_range_of_features">Wide range of features</h5><ul>
<li>Read only backing files</li>
<li>Snapshot (internal external)<ul>
<li>supports multiple virtual machine snapshots through a new, flexible model for storing snapshots.</li>
</ul>
</li>
<li>Zero clusters partial allocation </li>
<li>Compression<ul>
<li>zlib</li>
</ul>
</li>
<li>Encryption<ul>
<li>128-bit AES-CBC</li>
</ul>
</li>
</ul>
<h5 id="Create_QCOW2_image">Create QCOW2 image</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img create <span class="operator">-f</span> qcow2 rico.qcow2 <span class="number">5</span>G</span><br><span class="line">$ qemu-info rico.qcow2</span><br><span class="line">image: rico.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="supported_options">supported options</h5><ul>
<li>compat</li>
<li>backing_file</li>
<li>backing_fmt</li>
<li>encryption</li>
<li>cluster_size</li>
<li>preallocation</li>
<li>lazy_refcounts</li>
<li>nocow</li>
</ul>
<h4 id="backing_file">backing file</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img create -b rico.qcow2 <span class="operator">-f</span> qcow2 rico-<span class="number">1</span>.qcow2</span><br><span class="line">$ qemu-img info</span><br><span class="line">image: rico-<span class="number">1</span>.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">backing file: rico.qcow2</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create backing based on rico-1.qcow2</span></span><br><span class="line">$ qemu-img create -b rico-<span class="number">1</span>.qcow2 <span class="operator">-f</span> qcow2 rico-<span class="number">1</span>A.qcow2</span><br><span class="line">$ qemu-img info --backing-chain rico-<span class="number">1</span>A.qcow2</span><br><span class="line">image: rico-<span class="number">1</span>A.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">backing file: rico-<span class="number">1</span>.qcow2</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">image: rico-<span class="number">1</span>.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">backing file: rico.qcow2</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">image: rico.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: <span class="number">5.0</span>G (<span class="number">5368709120</span> bytes)</span><br><span class="line">disk size: <span class="number">196</span>K</span><br><span class="line">cluster_size: <span class="number">65536</span></span><br><span class="line">Format specific information:</span><br><span class="line">    compat: <span class="number">1.1</span></span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: <span class="number">16</span></span><br><span class="line">    corrupt: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>Backing files are always opened <strong>read-only</strong>.</p>
<h4 id="example:">example:</h4><p>base &lt;- sn1 &lt;- sn2 &lt;- sn3 </p>
<p>現在要刪掉 sn2
有兩個方法 </p>
<ol>
<li><p>把 sn2 merge 到 sn1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-img commit sn2.qcow2</span><br><span class="line">qemu-img rebase -u -b sn1.qcow2 sn3.qcow2</span><br></pre></td></tr></table></figure>
</li>
<li><p>把 sn2 merge 到 sn3 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-img commit sn2.qcow2</span><br><span class="line">qemu-img rebase -u -b sn1.qcow2 sn3.qcow2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Shapshots">Shapshots</h4><ul>
<li>internal<ul>
<li>A type of snapshot, where a single QCOW2 file will hold both the ‘saved state’ and the ‘delta’ since that saved point. ‘Internal snapshots’ are very handy because it’s only a single file where all the snapshot info. is captured, and easy to copy/move around the machines.</li>
</ul>
</li>
<li>external (backing file)<ul>
<li>Here, the ‘original qcow2 file’ will be in a ‘read-only’ saved state, and the new qcow2 file(which will be generated once snapshot is created) will be the delta for the changes. So, all the changes will now be written to this delta file. ‘External Snapshots’ are useful for <strong>performing backups</strong>. Also, external snapshot creates a qcow2 file with the original file as its backing image, and the backing file can be /read/ in parallel with the running qemu.</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img snapshot -c snap1 rico-<span class="number">1</span>A.qcow2</span><br><span class="line">$ qemu-img snapshot -c snap2 rico-<span class="number">1</span>A.qcow2</span><br><span class="line">$ qemu-img snapshot <span class="operator">-l</span> rico-<span class="number">1</span>A.qcow2 </span><br><span class="line">Snapshot list:</span><br><span class="line">ID        TAG                 VM SIZE                DATE       VM CLOCK</span><br><span class="line"><span class="number">1</span>         snap1                     <span class="number">0</span> <span class="number">2015</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">58</span>:<span class="number">36</span>   <span class="number">00</span>:<span class="number">00</span>:<span class="number">00.000</span></span><br><span class="line"><span class="number">2</span>         snap2                     <span class="number">0</span> <span class="number">2015</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">59</span>:<span class="number">36</span>   <span class="number">00</span>:<span class="number">00</span>:<span class="number">00.000</span></span><br></pre></td></tr></table></figure>
<p><a href="https://kashyapc.fedorapeople.org/virt/lc-2012/snapshots-handout.html" target="_blank" rel="external">https://kashyapc.fedorapeople.org/virt/lc-2012/snapshots-handout.html</a>
<a href="http://wiki.qemu.org/Features/Snapshots" target="_blank" rel="external">http://wiki.qemu.org/Features/Snapshots</a>
<a href="http://wiki.qemu.org/Features/Snapshots2" target="_blank" rel="external">http://wiki.qemu.org/Features/Snapshots2</a></p>
<h3 id="General">General</h3><p>A qcow2 image file is organized in units of constant size, which are called (host) clusters. A cluster is the unit in which all allocations are done, both for actual guest data and for image metadata.</p>
<p>Likewise, the virtual disk as seen by the guest is divided into (guest) clusters of the same size.</p>
<p>All numbers in qcow2 are stored in Big Endian byte order.</p>
<h3 id="Header">Header</h3><p>the default value of qcow2
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAGIC (('Q' &lt;&lt; 24) | ('F' &lt;&lt; 16) | ('I' &lt;&lt; 8) | 0xfb)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_CRYPT_NONE 0</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_CRYPT_AES  1</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_CRYPT_CLUSTERS 32</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_SNAPSHOTS 65536</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8 MB refcount table is enough for 2 PB images at 64k cluster size</span><br><span class="line"> * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_REFTABLE_SIZE 0x800000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 32 MB L1 table is enough for 2 PB images at 64k cluster size</span><br><span class="line"> * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_L1_SIZE 0x2000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allow for an average of 1k per snapshot table entry, should be plenty of</span><br><span class="line"> * space for snapshot names and IDs */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_MAX_SNAPSHOTS_SIZE (1024 * QCOW_MAX_SNAPSHOTS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* indicate that the refcount of the referenced cluster is exactly one. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_OFLAG_COPIED     (1ULL &lt;&lt; 63)</span></span><br><span class="line"><span class="comment">/* indicate that the cluster is compressed (they never have the copied flag) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_OFLAG_COMPRESSED (1ULL &lt;&lt; 62)</span></span><br><span class="line"><span class="comment">/* The cluster reads as all zeros */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QCOW_OFLAG_ZERO (1ULL &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MIN_CLUSTER_BITS 9</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_CLUSTER_BITS 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Must be at least 2 to cover COW */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MIN_L2_CACHE_SIZE 2 /* clusters */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Must be at least 4 to cover all cases of refcount table growth */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MIN_REFCOUNT_CACHE_SIZE 4 /* clusters */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Whichever is more */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFAULT_L2_CACHE_CLUSTERS 8 /* clusters */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFAULT_L2_CACHE_BYTE_SIZE 1048576 /* bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The refblock cache needs only a fourth of the L2 cache size to cover as many</span><br><span class="line"> * clusters */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFAULT_L2_REFCOUNT_SIZE_RATIO 4</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DEFAULT_CLUSTER_SIZE 65536</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> QCowHeader &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> magic;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    uint64_t backing_file_offset;</span><br><span class="line">    <span class="keyword">uint32_t</span> backing_file_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cluster size = 1 &lt;&lt; cluster_bits</span><br><span class="line">     * 9 &lt;= cluster_bits &lt;= 21</span><br><span class="line">     * 512B &lt;= cluster size &lt;= 2M </span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cluster_bits;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* virtual disk size in bytes ex 100M = 0x0000000006400000 */</span></span><br><span class="line">    uint64_t size; <span class="comment">/* in bytes */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> crypt_method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of entries in the active L1 table (8 bytes) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> l1_size; <span class="comment">/* <span class="label">XXX: save number of clusters instead ? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Offset into the image file at which the active L1 table starts. Must be aligned to a cluster boundary. ex 0x0000000000030000 */</span></span><br><span class="line">    uint64_t l1_table_offset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Offset into the image file at which the refcount table starts. Must be aligned to a cluster boundary. ex 0x0000000000010000 */</span></span><br><span class="line">    uint64_t refcount_table_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of clusters that the refcount table occupies. initialized value = 1</span><br><span class="line">     * describes the size of the refcount table.</span><br><span class="line">     */</span></span><br><span class="line">    uint32_t refcount_table_clusters;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Max number of snapshots is 64K */</span></span><br><span class="line">    uint32_t nb_snapshots;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Offset into the image file at which the snapshot table starts. Must be aligned to a cluster boundary. zero if has no snapshot. */</span></span><br><span class="line">    uint64_t snapshots_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields are only valid for version &gt;= 3</span><br><span class="line">     * Bit 0: Dirty bit. If this bit is set then refcounts may be inconsistent, make sure to scan L1/L2 tables to repair refcounts before accessing the image.</span><br><span class="line">     * Bit 1: Corrupt bit. If this bit is set then any data structure may be corrupt and the image must not be written to (unless for regaining consistency).</span><br><span class="line">     */</span></span><br><span class="line">    uint64_t incompatible_features;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lazy refcounts bit. If this bit is set then lazy refcount updates can be used. This means marking the image file dirty and postponing refcount metadata updates. */</span></span><br><span class="line">    uint64_t compatible_features;</span><br><span class="line">    uint64_t autoclear_features;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Describes the width of a reference count block entry (width in bits: refcount_bits = 1 &lt;&lt; refcount_order). For version 2 images, the order is always assumed to be 4 (i.e. refcount_bits = 16). This value may not exceed 6 (i.e. refcount_bits = 64).</span><br><span class="line">     * refcount_order = 4 =&gt; refcount block entry size = 2 bytes</span><br><span class="line">     */</span></span><br><span class="line">    uint32_t refcount_order;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Length of the header structure in bytes. For version 2 images, the length is always assumed to be 72 bytes. version 3 is 104 bytes */</span></span><br><span class="line">    uint32_t header_length;</span><br><span class="line">&#125; QEMU_PACKED QCowHeader;</span></span><br></pre></td></tr></table></figure>
<h3 id="Header_Extension">Header Extension</h3><p><strong>Directly after the image header</strong>, optional sections called header extensions can be stored. Each extension has a structure like the following:
Byte</p>
<ul>
<li>0-3: Header extension type:<ul>
<li>0x00000000  - End of the header extension area</li>
<li>0xE2792ACA - Backing file format name</li>
<li>0x6803F857 - Feature name table</li>
<li>other            - Unknown header extension, can be safely ignored</li>
</ul>
</li>
<li>4-7: Length of the header extension data.</li>
<li>8-n: Header extension data.</li>
<li>n-m: Padding to round up the header extension size to the next multiple of 8.</li>
</ul>
<p>defined in block/qcow2.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> magic;</span><br><span class="line">    <span class="keyword">uint32_t</span> len;</span><br><span class="line">&#125; QEMU_PACKED QCowExtension;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  QCOW2_EXT_MAGIC_END 0</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  QCOW2_EXT_MAGIC_BACKING_FORMAT 0xE2792ACA</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  QCOW2_EXT_MAGIC_FEATURE_TABLE 0x6803f857</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Backing_file">Backing file</h4><p>0xE2792ACA,00000005,71636F77,32000000</p>
<p>the header extension data is 0x71636F7732 = &#39;q&#39;, &#39; c&#39;, &#39;o&#39;, &#39;w&#39;, &#39;2&#39;.</p>
<p>If the image has a backing file then the backing file name should be stored in the remaining space <strong>between the end of the headers extension area and the end of the first cluster</strong>. It is not allowed to store other data here, so that an implementation can safely modify the header and add extensions without harming data of compatible features that is doesn&#39;t support. Compatible features that need space for additional data can use a header extension.</p>
<h4 id="Feature_name_table">Feature name table</h4><p>The feature name table is an optional header extension that contains the name for features used by the image. It can be used by applications that don&#39;t know the respective feature (e.g. because the feature was introduced only later) to display a useful error message.</p>
<p>defined in block/qcow2.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Qcow2Feature &#123;</span><br><span class="line">    <span class="comment">/* Type of feature (select feature bitmap)</span><br><span class="line">     *    0: Incompatible feature</span><br><span class="line">     *    1: Compatible feature</span><br><span class="line">     *    2: Autoclear feature</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Bit number within the selected feature bitmap (valid values: 0-63) */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bit;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Feature name (padded with zeros, but not necessarily null terminated if it has full length) */</span></span><br><span class="line">    <span class="keyword">char</span>    name[<span class="number">46</span>];</span><br><span class="line">&#125; QEMU_PACKED Qcow2Feature;</span><br></pre></td></tr></table></figure></p>
<p><strong>the size of feature is 0x30 bytes</strong>.</p>
<p>0x6803F857,00000090, 00006469....(multiple feature table)</p>
<p>the feature that length 144 bytes = 48 / 3 = 3 feature</p>
<ul>
<li>dirty bit feature
0x00,00, 0x646972747920626974 (&quot;dirty bit&quot;) 000000...</li>
<li>corrupt bit feature
0x00,01 0x636F727275707420626974 (&quot;corrupt bit&quot;) 000000...</li>
<li>lazy refcounts feature
0x01,00 0x6C617A7920726566636F756E7473 (&quot;lazy refcounts&quot;) 000000.... </li>
</ul>
<h4 id="End_of_the_header_extension_area">End of the header extension area</h4><ul>
<li>end of the header type, data length is zero.
0x00000000,00000000</li>
</ul>
<h3 id="Host_Cluster_Management">Host Cluster Management</h3><p>qcow2 manages the allocation of host clusters by maintaining a refernce count for each host cluster. <strong>A refcount of 0 means that the cluster is free, 1 means that it is used, and &gt;= 2 means that it is used and any write access must perform a COW</strong> (copy on write) operation.</p>
<p>The refcounts are managed in a <strong>two-level table</strong>. The first level is called <strong>refcount table</strong> and has a variable size (which is stored in the header). The refcount table can cover multiple clusters, however it needs to be contiguous in the image file.</p>
<p><strong>It contains pointers to the second level structures which are called refcount blocks</strong> and are exactly <strong>one clusters in size</strong>.</p>
<p>Given a offset into the image file, the refcount of its cluster can be obtained as follows:</p>
<blockquote>
<p>refcount_block_entries = (cluster_size * 8 / refcount_bits)</p>
<p>refcount_block_index = (offset / cluster_size) % refcount_block_entires
refcount_table_index = (offset / cluster_size) / refcount_block_entires</p>
<p>refcount_block = load_cluster(refcount_table[refcount_table_index])
return refcount_block[refcount_block_index];</p>
</blockquote>
<p>cluster_size = 64K
refcount_order = 4 -&gt; refcount_bits = 16
=&gt; the size of a refcount block is 64K * 8 / 16 = 0x8000 = 32K</p>
<blockquote>
<pre><code>Given image offset <span class="number">0</span>x20000
<span class="variable">refcount_block_entries =</span> <span class="number">32</span>KB
<span class="variable">refcount_block_index =</span> <span class="number">0</span>x20000 / <span class="number">64</span>K % <span class="number">32</span><span class="variable">K =</span> <span class="number">0</span>
<span class="variable">refcount_table_index =</span> <span class="number">0</span>x20000 / <span class="number">64</span>K / <span class="number">32</span><span class="variable">K =</span> <span class="number">0</span>


Given image offset <span class="number">0</span>x7FE00
<span class="variable">refcount_block_entries =</span> <span class="number">32</span>KB
<span class="variable">refcount_block_index =</span> <span class="number">0</span>x7FE00 / <span class="number">64</span>K % <span class="number">32</span><span class="variable">K =</span> <span class="number">7</span>
<span class="variable">refcount_table_index =</span> <span class="number">0</span>x7FE00 / <span class="number">64</span>K / <span class="number">32</span><span class="variable">K =</span> <span class="number">0</span>
</code></pre></blockquote>
<p>a refcount table can handle 64K * 32KB data</p>
<p><strong>L2 table size = cluster_size / 8</strong>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">    s-&gt;l2_bits = s-&gt;cluster_bits - 3; /* L2 is always one cluster */</span><br><span class="line">    s-&gt;l2_size = 1 &lt;&lt; s-&gt;l2_bits;</span><br><span class="line">    /* 2^(s-&gt;refcount_order - 3) is the refcount width in bytes */</span><br><span class="line">    s-&gt;refcount_block_bits = s-&gt;cluster_bits - (s-&gt;refcount_order - 3);</span><br><span class="line">    s-&gt;refcount_block_size = 1 &lt;&lt; s-&gt;refcount_block_bits;</span><br><span class="line">    bs-&gt;total_sectors = header.size / 512;</span><br><span class="line">    s-&gt;csize_shift = (62 - (s-&gt;cluster_bits - 8));</span><br><span class="line">    s-&gt;csize_mask = (1 &lt;&lt; (s-&gt;cluster_bits - 8)) - 1;</span><br><span class="line">    s-&gt;cluster_offset_mask = (1LL &lt;&lt; s-&gt;csize_shift) - 1;</span><br><span class="line"></span><br><span class="line">    s-&gt;refcount_table_offset = header.refcount_table_offset;</span><br><span class="line">    s-&gt;refcount_table_size =</span><br><span class="line">        header.refcount_table_clusters &lt;&lt; (s-&gt;cluster_bits - 3);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; if **refcount_order = 4, cluster_bits = 16, refcount_table_clusters = 1**</span><br><span class="line">&gt; refcount_block_bits = 16 - (4 - 3) = 15</span><br><span class="line">&gt; refcount_block_size = 1 &lt;&lt; 15 = 32KB</span><br><span class="line">&gt; refcount_table_size = 1 &lt;&lt; 13 = 8KB</span><br><span class="line">&gt; 8KB / 8B = 1K refcount table entry</span><br><span class="line"></span><br><span class="line">#### Refcount table entry (8 bytes)</span><br><span class="line">BIt</span><br><span class="line"></span><br><span class="line"> - 0-8</span><br><span class="line">Reserved (set to 0)</span><br><span class="line"> - 9-63</span><br><span class="line"> Bits 9-63 of **the offset into the image file at which the refcount block starts.** Must be aligned to a cluster boundary.</span><br><span class="line"> If this is 0, the corresponding refcount block has not yet been allocated. All refcounts managed by this refcount block are 0.</span><br><span class="line"></span><br><span class="line">ex:</span><br><span class="line"></span><br><span class="line">&gt; refcount table at offset 0x10000</span><br><span class="line">&gt; 0x0000, 000000020000 =&gt; offset 0x20000</span><br><span class="line"></span><br><span class="line">#### Refcount block entry ( width = refcount_bit )</span><br><span class="line">Bit</span><br><span class="line"></span><br><span class="line"> - 0-x (x = refcount_bits - 1)</span><br><span class="line">**Reference count of the cluster**. If refcount_bits implies a sub-type width, note that bit 0 means the least significant bit in this context.</span><br><span class="line"></span><br><span class="line">ex:</span><br><span class="line"></span><br><span class="line">&gt; refcount_order = 4 =&gt; refcount_bit = 16, block entry size is 2 bytes</span><br><span class="line">&gt; 0x0001, 0001, 0001, 0001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Cluster mapping</span><br><span class="line">Just as for refcounts, qcow2 use **a two-level structure for the mapping of guest clusters to host clusters**. They are called L1 and L2 table.</span><br><span class="line">The L1 table has a variable size (stored in the header) and may use multiple clusters, however it must be contiguous in the image file. L2 tables are exactly one cluster in size.</span><br><span class="line"></span><br><span class="line">Given a offset into the virtual disk, the offset into the image file can be obtained as follows:</span><br><span class="line"></span><br><span class="line">&gt; l2_entries = (cluster_size / sizeof(uint64_t) )</span><br><span class="line">&gt; </span><br><span class="line">&gt; l2_index = (offset / cluster_size) % l2_entries</span><br><span class="line">&gt; l1_index = (offset / cluster_size) / l2_entries</span><br><span class="line">&gt; </span><br><span class="line">&gt; l2_table = load_cluster(l1_table[l1_index]);</span><br><span class="line">&gt; cluster_offset = l2_table[l2_index];</span><br><span class="line">&gt; </span><br><span class="line">&gt; return cluster_offset + (offset % cluster_size)</span><br><span class="line"></span><br><span class="line">if  virtual disk offset = 1M, cluster_size = 64K</span><br><span class="line">&gt; l2_entries = cluster_size / 8 = 8KB</span><br><span class="line">&gt; **l2_index = 16 % 8K = 16**</span><br><span class="line">&gt; l1_index = 16 / 8K = 0</span><br><span class="line">&gt; **a L1 entry can handle 8K * 64KB =  512MB data**</span><br><span class="line">&gt; get the 16'd L2 entry in L2 table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if  virtual disk offset = 99M - 512, cluster_size = 64K</span><br><span class="line">&gt; l2_entries = cluster_size / 8 = 8KB</span><br><span class="line">&gt; **l2_index = 1583 % 8K = 1583**</span><br><span class="line">&gt; l1_index = 1583 / 8K = 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1. get the 1583'd L2 entry in L2 table</span><br><span class="line">&gt; 2. get cluster_offset from L2 entry</span><br><span class="line">&gt; 3. 0x70000 + (0xFE00) = 0x7FE00</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### L1 table entry (8 bytes)</span><br><span class="line">Bit</span><br><span class="line"></span><br><span class="line"> - 0-8:</span><br><span class="line">Reserved (set to 0)  ????</span><br><span class="line"> - 9-55:</span><br><span class="line">Bits 9-55 of **the offset into the image file at which the L2 table start**. Must be aligned to a cluster boundary. If the offset is 0, the L2 table and all clusters described by this L2 table are unallocated.</span><br><span class="line"> - 56-62:</span><br><span class="line">Reserved (set to 0)</span><br><span class="line"> - 63:</span><br><span class="line">0 for an L2 table that is **unused or requires COW**, 1 if its refcount is exactly one. This information is only accurate in the active L1 table.</span><br><span class="line"></span><br><span class="line">&gt; Given L1 table offset is 0x30000</span><br><span class="line">&gt; 0x80, 00000000040000</span><br><span class="line">&gt; L2 offset = 0x40000</span><br><span class="line"></span><br><span class="line">#### L2 table entry (8 bytes)</span><br><span class="line"></span><br><span class="line">Bit</span><br><span class="line"></span><br><span class="line"> - 0-61:</span><br><span class="line">Cluster descriptor</span><br><span class="line"> - 62:</span><br><span class="line">0 for standard clusters</span><br><span class="line">1 for compressed clusters</span><br><span class="line"> - 63:</span><br><span class="line">0 for a cluster that is **unused or requires COW**, 1 if its refcount is exactly one. This information is only accurate in L2 tables that are reachable form the active L1 table.</span><br><span class="line"></span><br><span class="line">&gt; a L2 table entry at 0x40000</span><br><span class="line">&gt; 10000000B,  0x00000000050000</span><br><span class="line"></span><br><span class="line">#### Standard Cluster Descriptor (62 bits)</span><br><span class="line"></span><br><span class="line">BIt</span><br><span class="line"></span><br><span class="line"> - 0:</span><br><span class="line">If set to 1, the cluster reads as all zeros. The host cluster offset can be used to describe a preallocation, but it won't be used for reading data from this cluster, nor is data read from the backing file if the cluster is unallocated.</span><br><span class="line"> - 1-8:</span><br><span class="line">Reserved (set to 0)</span><br><span class="line"> - 9-55:</span><br><span class="line">Bits 9-55 of host cluster offset. Must be aligned to a cluster boundary. If the offset is 0, the cluster is unallocated.</span><br><span class="line"> - 56-61:</span><br><span class="line">Reserved (set to 0)</span><br><span class="line"></span><br><span class="line">&gt; bit 0-55</span><br><span class="line">&gt; 0x00000000050000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Compressed Clusters</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Snapshots</span><br><span class="line"></span><br><span class="line">qcow2 supports internal snapshots. Their basic principle of operation is **to switch the active L1 table**, so that a different set of host clusters are exposed to the guest.</span><br><span class="line"></span><br><span class="line">When creating a snapshot, the L1 table should be copied and **the refcount of all L2 tables and clusters reachable from this L1 table must be increased**, so that **a write causes a COW** and isn't visible in other snapshots.</span><br><span class="line"></span><br><span class="line">When loading a snapshot, bit 63 of all entries in the new active L1 table and all L2 tables referenced by it **must be reconstructed** from the refcount table as it doesn't need to be accurate in inactive L1 tables.</span><br><span class="line"></span><br><span class="line">A directory of all snapshots is **stored in the snapshot table**, a contiguous area in the image file, whose starting **offset and length are given by the header** fields snapshots_offset and nb_snapshot. The entries of the snapshot table have variable length, depending on the length of ID, name and extra data.</span><br><span class="line"></span><br><span class="line">``` c</span><br><span class="line">typedef struct QEMU_PACKED QCowSnapshotHeader &#123;</span><br><span class="line">    /* header is 8 byte aligned */</span><br><span class="line">    uint64_t l1_table_offset;</span><br><span class="line"></span><br><span class="line">    uint32_t l1_size;</span><br><span class="line">    uint16_t id_str_size;</span><br><span class="line">    uint16_t name_size;</span><br><span class="line"></span><br><span class="line">    uint32_t date_sec;</span><br><span class="line">    uint32_t date_nsec;</span><br><span class="line"></span><br><span class="line">    uint64_t vm_clock_nsec;</span><br><span class="line"></span><br><span class="line">    uint32_t vm_state_size;</span><br><span class="line">    uint32_t extra_data_size; /* for extension */</span><br><span class="line">    /* extra data follows */</span><br><span class="line">    /* id_str follows */</span><br><span class="line">    /* name follows  */</span><br><span class="line">&#125; QCowSnapshotHeader;</span><br></pre></td></tr></table></figure></p>
<h3 id="QEMU_Cache">QEMU Cache</h3><p>default cache size is 1M</p>
<p>cache mode</p>
<ul>
<li>none<ul>
<li>host do not do cache, guest disk cache is wb. </li>
</ul>
</li>
<li>writeback<ul>
<li>host do read/write cache, guest disk cache is writeback</li>
</ul>
</li>
<li>writethrough<ul>
<li>host do read cache, guest disk cache is writethrough.</li>
</ul>
</li>
<li>unsafe<ul>
<li>host do not flush cache, guest disk cache is writeback</li>
</ul>
</li>
<li>directsync<ul>
<li>host do not do cache, guest disk cache is writethrough<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Set open flags for a given cache mode</span><br><span class="line"> *</span><br><span class="line"> * Return 0 on success, -1 if the cache mode was invalid.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * BDRV_O_NOCACHE: host end 繞過 cache</span><br><span class="line"> * BDRV_O_CACHE_WB: guest 啟用 writeback cache</span><br><span class="line"> * BDRV_O_NO_FLUSH: host end 不同步 cache</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bdrv_parse_cache_flags</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">int</span> *flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    *flags &amp;= ~BDRV_O_CACHE_MASK;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(mode, <span class="string">"off"</span>) || !<span class="built_in">strcmp</span>(mode, <span class="string">"none"</span>)) &#123;</span><br><span class="line">        *flags |= BDRV_O_NOCACHE | BDRV_O_CACHE_WB;</span><br><span class="line">        <span class="comment">// host no cache, guest has wb cache</span></span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(!<span class="built_in">strcmp</span>(mode, "directsync")</span>) </span>&#123;</span><br><span class="line">        *flags |= BDRV_O_NOCACHE;</span><br><span class="line">        <span class="comment">// host and guest no cache</span></span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(!<span class="built_in">strcmp</span>(mode, "writeback")</span>) </span>&#123;</span><br><span class="line">        *flags |= BDRV_O_CACHE_WB;</span><br><span class="line">        <span class="comment">// host and guest has wb cache</span></span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(!<span class="built_in">strcmp</span>(mode, "unsafe")</span>) </span>&#123;</span><br><span class="line">        *flags |= BDRV_O_CACHE_WB;</span><br><span class="line">        *flags |= BDRV_O_NO_FLUSH;</span><br><span class="line">        <span class="comment">// host 不 flush cache, guest 有 cache</span></span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(!<span class="built_in">strcmp</span>(mode, "writethrough")</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* this is the default */</span></span><br><span class="line">        <span class="comment">// host 有 cache, guest 沒有</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="LVM_+_qcow2">LVM + qcow2</h4><p> Thin Provision
<a href="http://mathslinux.org/?p=379" target="_blank" rel="external">http://mathslinux.org/?p=379</a></p>
<h3 id="Snapshot">Snapshot</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> QEMU_PACKED QCowSnapshotHeader &#123;</span><br><span class="line">    <span class="comment">/* header is 8 byte aligned */</span></span><br><span class="line">    uint64_t l1_table_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> l1_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> id_str_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> name_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> date_sec;</span><br><span class="line">    <span class="keyword">uint32_t</span> date_nsec;</span><br><span class="line"></span><br><span class="line">    uint64_t vm_clock_nsec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_state_size;</span><br><span class="line">    <span class="keyword">uint32_t</span> extra_data_size; <span class="comment">/* for extension */</span></span><br><span class="line">    <span class="comment">/* extra data follows */</span></span><br><span class="line">    <span class="comment">/* id_str follows */</span></span><br><span class="line">    <span class="comment">/* name follows  */</span></span><br><span class="line">&#125; QCowSnapshotHeader;</span><br></pre></td></tr></table></figure>
<h3 id="QEMUFile">QEMUFile</h3><p>defined in migration/qemu-file-internal.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> QEMUFile &#123;</span><br><span class="line">    <span class="keyword">const</span> QEMUFileOps *ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* assign BlockDriverState */</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> bytes_xfer;</span><br><span class="line">    <span class="keyword">int64_t</span> xfer_limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> pos; <span class="comment">/* start of buffer when writing, end of buffer</span><br><span class="line">                    when reading */</span></span><br><span class="line">    <span class="keyword">int</span> buf_index;</span><br><span class="line">    <span class="keyword">int</span> buf_size; <span class="comment">/* 0 when writing */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> buf[IO_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> iovec iov[MAX_IOV_SIZE];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> iovcnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last_error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>defined in migration/savevm.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* savevm/loadvm support */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">block_writev_buffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt,</span><br><span class="line">                                   <span class="keyword">int64_t</span> pos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    QEMUIOVector qiov;</span><br><span class="line"></span><br><span class="line">    qemu_iovec_init_external(&amp;qiov, iov, iovcnt);</span><br><span class="line">    ret = bdrv_writev_vmstate(opaque, &amp;qiov, pos);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qiov.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">block_put_buffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf,</span><br><span class="line">                                <span class="keyword">int64_t</span> pos, size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    bdrv_save_vmstate(opaque, buf, pos, size);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">block_get_buffer</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int64_t</span> pos,</span><br><span class="line">                                size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bdrv_load_vmstate(opaque, buf, pos, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bdrv_fclose</span><span class="params">(<span class="keyword">void</span> *opaque)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bdrv_flush(opaque);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> QEMUFileOps bdrv_read_ops = &#123;</span><br><span class="line">    .get_buffer = block_get_buffer,</span><br><span class="line">    .close =      bdrv_fclose</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> QEMUFileOps bdrv_write_ops = &#123;</span><br><span class="line">    .put_buffer     = block_put_buffer,</span><br><span class="line">    .writev_buffer  = block_writev_buffer,</span><br><span class="line">    .close          = bdrv_fclose</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QEMUFile *qemu_fopen_bdrv(BlockDriverState *bs, <span class="keyword">int</span> is_writable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_writable) &#123;</span><br><span class="line">        <span class="keyword">return</span> qemu_fopen_ops(bs, &amp;bdrv_write_ops);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qemu_fopen_ops(bs, &amp;bdrv_read_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>defined in block/block_int.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> BlockDriverState &#123;</span><br><span class="line">    <span class="keyword">int64_t</span> total_sectors; <span class="comment">/* if we are reading a disk image, give its</span><br><span class="line">                              size in sectors */</span></span><br><span class="line">    <span class="keyword">int</span> read_only; <span class="comment">/* if true, the media is read only */</span></span><br><span class="line">    <span class="keyword">int</span> open_flags; <span class="comment">/* flags used to open the file, re-used for re-open */</span></span><br><span class="line">    <span class="keyword">int</span> encrypted; <span class="comment">/* if true, the media is encrypted */</span></span><br><span class="line">    <span class="keyword">int</span> valid_key; <span class="comment">/* if true, a valid encryption key has been set */</span></span><br><span class="line">    <span class="keyword">int</span> sg;        <span class="comment">/* if true, the device is a /dev/sg* */</span></span><br><span class="line">    <span class="keyword">int</span> copy_on_read; <span class="comment">/* if true, copy read backing sectors into image</span><br><span class="line">                         note this is a reference count */</span></span><br><span class="line">    <span class="keyword">bool</span> probed;</span><br><span class="line"></span><br><span class="line">    BlockDriver *drv; <span class="comment">/* NULL means no media */</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    BlockBackend *blk;          <span class="comment">/* owning backend, if any */</span></span><br><span class="line"></span><br><span class="line">    AioContext *aio_context; <span class="comment">/* event loop used for fd handlers, timers, etc */</span></span><br><span class="line">    <span class="comment">/* long-running tasks intended to always use the same AioContext as this</span><br><span class="line">     * BDS may register themselves in this list to be notified of changes</span><br><span class="line">     * regarding this BDS's context */</span></span><br><span class="line">    QLIST_HEAD(, BdrvAioNotifier) aio_notifiers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> filename[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> backing_file[PATH_MAX]; <span class="comment">/* if non zero, the image is a diff of</span><br><span class="line">                                    this file image */</span></span><br><span class="line">    <span class="keyword">char</span> backing_format[<span class="number">16</span>]; <span class="comment">/* if non-zero and backing_file exists */</span></span><br><span class="line"></span><br><span class="line">    QDict *full_open_options;</span><br><span class="line">    <span class="keyword">char</span> exact_filename[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    BlockDriverState *backing_hd;</span><br><span class="line">    BdrvChild *backing_child;</span><br><span class="line">    BlockDriverState *file;</span><br><span class="line"></span><br><span class="line">    NotifierList close_notifiers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Callback before write request is processed */</span></span><br><span class="line">    NotifierWithReturnList before_write_notifiers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* number of in-flight serialising requests */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> serialising_in_flight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I/O throttling */</span></span><br><span class="line">    CoQueue      throttled_reqs[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">bool</span>         io_limits_enabled;</span><br><span class="line">    <span class="comment">/* The following fields are protected by the ThrottleGroup lock.</span><br><span class="line">     * See the ThrottleGroup documentation for details. */</span></span><br><span class="line">    ThrottleState *throttle_state;</span><br><span class="line">    ThrottleTimers throttle_timers;</span><br><span class="line">    <span class="keyword">unsigned</span>       pending_reqs[<span class="number">2</span>];</span><br><span class="line">    QLIST_ENTRY(BlockDriverState) round_robin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I/O stats (display with "info blockstats"). */</span></span><br><span class="line">    BlockAcctStats stats;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I/O Limits */</span></span><br><span class="line">    BlockLimits bl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whether produces zeros when read beyond eof */</span></span><br><span class="line">    <span class="keyword">bool</span> zero_beyond_eof;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Alignment requirement for offset/length of I/O requests */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> request_alignment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the block size for which the guest device expects atomicity */</span></span><br><span class="line">    <span class="keyword">int</span> guest_block_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do we need to tell the quest if we have a volatile write cache? */</span></span><br><span class="line">    <span class="keyword">int</span> enable_write_cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NOTE: the following infos are only hints for real hardware</span><br><span class="line">       drivers. They are not used by the block driver */</span></span><br><span class="line">    BlockdevOnError on_read_error, on_write_error;</span><br><span class="line">    <span class="keyword">bool</span> iostatus_enabled;</span><br><span class="line">    BlockDeviceIoStatus iostatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the following member gives a name to every node on the bs graph. */</span></span><br><span class="line">    <span class="keyword">char</span> node_name[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">/* element of the list of named nodes building the graph */</span></span><br><span class="line">    QTAILQ_ENTRY(BlockDriverState) node_list;</span><br><span class="line">    <span class="comment">/* element of the list of "drives" the guest sees */</span></span><br><span class="line">    QTAILQ_ENTRY(BlockDriverState) device_list;</span><br><span class="line">    QLIST_HEAD(, BdrvDirtyBitmap) dirty_bitmaps;</span><br><span class="line">    <span class="keyword">int</span> refcnt;</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, BdrvTrackedRequest) tracked_requests;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* operation blockers */</span></span><br><span class="line">    QLIST_HEAD(, BdrvOpBlocker) op_blockers[BLOCK_OP_TYPE_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* long-running background operation */</span></span><br><span class="line">    BlockJob *job;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The node that this node inherited default options from (and a reopen on</span><br><span class="line">     * which can affect this node by changing these defaults). This is always a</span><br><span class="line">     * parent node of this node. */</span></span><br><span class="line">    BlockDriverState *inherits_from;</span><br><span class="line">    QLIST_HEAD(, BdrvChild) children;</span><br><span class="line"></span><br><span class="line">    QDict *options;</span><br><span class="line">    BlockdevDetectZeroesOptions detect_zeroes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The error object in use for blocking operations on backing_hd */</span></span><br><span class="line">    Error *backing_blocker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* threshold limit for writes, in bytes. "High water mark". */</span></span><br><span class="line">    uint64_t write_threshold_offset;</span><br><span class="line">    NotifierWithReturn write_threshold_notifier;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="SaveState">SaveState</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SaveVMHandlers &#123;</span><br><span class="line">    <span class="comment">/* This runs inside the iothread lock.  */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_params)(<span class="keyword">const</span> MigrationParams *params, <span class="keyword">void</span> * opaque);</span><br><span class="line">    SaveStateHandler *save_state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*cancel)(<span class="keyword">void</span> *opaque);</span><br><span class="line">    <span class="keyword">int</span> (*save_live_complete)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This runs both outside and inside the iothread lock.  */</span></span><br><span class="line">    <span class="keyword">bool</span> (*is_active)(<span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This runs outside the iothread lock in the migration case, and</span><br><span class="line">     * within the lock in the savevm case.  The callback had better only</span><br><span class="line">     * use data that is local to the migration thread or protected</span><br><span class="line">     * by other locks.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*save_live_iterate)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This runs outside the iothread lock!  */</span></span><br><span class="line">    <span class="keyword">int</span> (*save_live_setup)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line">    uint64_t (*save_live_pending)(QEMUFile *f, <span class="keyword">void</span> *opaque, uint64_t max_size);</span><br><span class="line"></span><br><span class="line">    LoadStateHandler *load_state;</span><br><span class="line">&#125; SaveVMHandlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SaveStateEntry &#123;</span><br><span class="line">    QTAILQ_ENTRY(SaveStateEntry) entry;</span><br><span class="line">    <span class="keyword">char</span> idstr[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> instance_id;</span><br><span class="line">    <span class="keyword">int</span> alias_id;</span><br><span class="line">    <span class="keyword">int</span> version_id;</span><br><span class="line">    <span class="keyword">int</span> section_id;</span><br><span class="line">    SaveVMHandlers *ops;</span><br><span class="line">    <span class="keyword">const</span> VMStateDescription *vmsd;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    CompatEntry *compat;</span><br><span class="line">    <span class="keyword">int</span> is_ram;</span><br><span class="line">&#125; SaveStateEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SaveState &#123;</span><br><span class="line">    QTAILQ_HEAD(, SaveStateEntry) handlers;</span><br><span class="line">    <span class="keyword">int</span> global_section_id;</span><br><span class="line">    <span class="keyword">bool</span> skip_configuration;</span><br><span class="line">    <span class="keyword">uint32_t</span> len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">&#125; SaveState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> SaveState savevm_state = &#123;</span><br><span class="line">    .handlers = QTAILQ_HEAD_INITIALIZER(savevm_state.handlers),</span><br><span class="line">    .global_section_id = <span class="number">0</span>,</span><br><span class="line">    .skip_configuration = <span class="keyword">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>register handlers
register_savevm()</p>
<h3 id="VMState">VMState</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int64_t</span> <span class="title">size_to_l1</span><span class="params">(BDRVQcow2State *s, <span class="keyword">int64_t</span> size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shift = s-&gt;cluster_bits + s-&gt;l2_bits;</span><br><span class="line">    <span class="keyword">return</span> (size + (<span class="number">1U</span>LL &lt;&lt; shift) - <span class="number">1</span>) &gt;&gt; shift;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int64_t</span> <span class="title">qcow2_vm_state_offset</span><span class="params">(BDRVQcow2State *s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int64_t</span>)s-&gt;l1_vm_state_index &lt;&lt; (s-&gt;cluster_bits + s-&gt;l2_bits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s-&gt;l1_vm_state_index = size_to_l1(s, header.size);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>VM state save at qcow2_vm_state_offset()
=1 &lt;&lt; 29 = 0x20000000 = 512M</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/09/24/qcow2-format/" data-id="ciho8m29j000143ifn4sk2dru" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Linux-qemu/">Linux,qemu</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Software-switches-in-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/09/22/Software-switches-in-Linux/" class="article-date">
  <time datetime="2015-09-22T08:51:12.000Z" itemprop="datePublished">2015-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/09/22/Software-switches-in-Linux/">Software switches in Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Linux_has_3_types_of_software_switches">Linux has 3 types of software switches</h2><ul>
<li>bridge</li>
<li>macvlan</li>
<li>Open vSwitch</li>
</ul>
<p><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/" target="_blank" rel="external">http://www.linuxfoundation.org/collaborate/workgroups/networking/</a></p>
<h3 id="bridge_(IEEE_802-1D)">bridge (IEEE 802.1D)</h3><ul>
<li>fdb (Forwarding DB)<ul>
<li>Each Bridge instance has its own forwarding database used regardless whether STP is run or not.</li>
<li>The Forwarding database is placed in the net_bridge data structure and defined as hash table.</li>
<li>An instance of the net_bridge_fdb_entry data structure is added to the database for each MAC address learnt on the bridge ports.</li>
</ul>
</li>
</ul>
<p><a href="http://bitwisertraining.com/8021DSTD/Introduction.htm" target="_blank" rel="external">http://bitwisertraining.com/8021DSTD/Introduction.htm</a>
<a href="http://bitwisertraining.com/8021DSTD/M1L2P1.htm" target="_blank" rel="external">http://bitwisertraining.com/8021DSTD/M1L2P1.htm</a></p>
<p><a href="http://blog.xuite.net/ivan1193/blog/7801194-Spanning+Tree+Protocol+" target="_blank" rel="external">http://blog.xuite.net/ivan1193/blog/7801194-Spanning+Tree+Protocol+</a></p>
<ul>
<li>Using <strong>promiscuous mode</strong> that allows to receive all packets<ul>
<li>Common NIC filters unicast whose dst is not its mac address
without promiscuous mode</li>
<li>Many NICs also filter multicast / vlan-tagged packets by default</li>
</ul>
</li>
</ul>
<p><a href="http://kernelnewbies.org/Bridging_and_Forwarding" target="_blank" rel="external">http://kernelnewbies.org/Bridging_and_Forwarding</a></p>
<h3 id="macvlan">macvlan</h3><p>VLAN using not 802.1Q tag but <strong>mac address</strong></p>
<ul>
<li><p>4 types of mode</p>
<ul>
<li>bridge</li>
<li>vepa (Virtual Ethernet Port Aggregator)</li>
<li>private</li>
<li>passthrough</li>
</ul>
</li>
<li><p>Using <strong>unicast filtering</strong> if supported, instead of promiscuous mode (except for passthrough)</p>
</li>
</ul>
<p><a href="http://virt.kernelnewbies.org/MacVTap" target="_blank" rel="external">http://virt.kernelnewbies.org/MacVTap</a>
<a href="http://www.kernelchina.org/node/214" target="_blank" rel="external">http://www.kernelchina.org/node/214</a></p>
<h3 id="Open_vSwitch">Open vSwitch</h3><h3 id="Hardware_Switch">Hardware Switch</h3><ul>
<li>SR-IOV (single root I/O virtualization)</li>
</ul>
<p>SR-IOV allows a device, such as a network adapter, to separate access to its resources among various PCIe hardware functions. These functions consist of the following types:</p>
<ul>
<li>PF (Physical Function)</li>
<li>VF (Virtual Function)</li>
</ul>
<p>PF 與 VF 之間的溝通透過 Layer2 的 classifier/sorter switch 處理。</p>
<p>Example</p>
<ol>
<li>packet arrived</li>
<li>send to L2 sorter</li>
<li>sorted based upon mac/vlan, placed into queue/pool</li>
<li>DMA action initiated (by Intel chipset )</li>
<li>VT-d re-maps DMA address</li>
</ol>
<p>Removes CPU from the process of moving data to and from a VM. Data is DMA&#39;d directly to and from a VM without the software switch in the VMM ever &#39;touching&#39; it.</p>
<p><a href="https://msdn.microsoft.com/en-us/library/windows/hardware/hh440148(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/hardware/hh440148(v=vs.85).aspx</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/09/22/Software-switches-in-Linux/" data-id="ciho8m29x000d43ifac4dvshr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Linux-Network-KVM/">Linux,Network,KVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-fPIC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/06/15/fPIC/" class="article-date">
  <time datetime="2015-06-15T06:54:41.000Z" itemprop="datePublished">2015-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/06/15/fPIC/">fPIC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction_to_PIC_-_(Position_Independent_Code)">Introduction to PIC - (Position Independent Code)</h3><p>PIC code differs from traditional code in the method it will perform access to function code and data objects/variables through an indirect accessing table. This table is called the &quot;Global Offset Table&quot; because it contains the addresses of code functions and data objects exported by a shared library.</p>
<p>The dynamic loader modifies the GOT slots to resemble the current memory address for every exported symbol in the library. When the dynamic loader has completed, the GOT contains full absolute addresses for each symbol reference constructed from the load address (PT_LOAD) of the shared library that contains these symbols plus their offset inside this shared library. </p>
<h3 id="shared_library">shared library</h3><p>一般編譯 shared library 都會加上 -fPIC
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c -o <span class="operator">-f</span>PIC</span><br><span class="line">gcc b.c -o <span class="operator">-f</span>PIC</span><br><span class="line">gcc --shared -o libab.so a.o b.o</span><br></pre></td></tr></table></figure></p>
<h3 id="The_Global_Offset_Table_(GOT)">The Global Offset Table (GOT)</h3><p>GOT 位於 data section，保存 symbol address 的表格。</p>
<h3 id="The_Procedure_Linkage_Table_(PLT)">The Procedure Linkage Table (PLT)</h3><h3 id="Position_Independent_Code(PIC)">Position Independent Code(PIC)</h3><p>主要的關鍵是取得 text section 和 data section的位移，text section 會緊跟在 data section 之後，所以給定一個在 text section 中的指令，那麼這個指令到 data section 的開頭的位移就是 text section 的大小減去指令在text section裡的位移。
算出了 offset 要取得 data section裡的資料，需要 instruction 的位址，但 x86 沒有取得 EIP 的指令，所以可以利用一些方法取得：
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">        call label&#10;label:&#10;        pop ebx&#10;``` &#10;1. call &#26371;&#25226;&#19979;&#19968;&#34892;&#25351;&#20196;&#30340;&#20301;&#22336; push &#21040; stack&#12290;&#10;2. &#36339;&#21040; label&#12290;&#10;3. stack pop &#21040; ebx register&#65292;ebx &#23601;&#26159; label &#25152;&#22312;&#30340;&#20301;&#22336;&#12290;&#10;&#10;```asm&#10;; 1. Somehow get the address of the GOT into ebx&#10;lea ebx, ADDR_OF_GOT&#10;&#10;; 2. Suppose ADDR_OF_VAR is stored at offset 0x10&#10;;    in the GOT. Then this will place ADDR_OF_VAR&#10;;    into edx.&#10;mov edx, DWORD PTR [ebx + 0x10]&#10;&#10;; 3. Finally, access the variable and place its&#10;;    value into edx.&#10;mov edx, DWORD PTR [edx]</span><br></pre></td></tr></table></figure></p>
<p>藉由 GOT 來 relocation 避免在 text section 進行，如此 text section 就可以是 read-only 並且共享。比起在 text section 作 relocation，GOT 只需對一個變數進行，因此較有效率。</p>
<h3 id="Example">Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_foo</span><span class="params">(<span class="keyword">int</span> foo)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        _foo = foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_foo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000054c &#60;set_foo&#62;:&#10; 54c:   55                      push   %ebp&#10; 54d:   89 e5                   mov    %esp,%ebp&#10; 54f:   e8 2b 00 00 00          call   57f &#60;__x86.get_pc_thunk.cx&#62;&#10; 554:   81 c1 ac 1a 00 00       add    $0x1aac,%ecx&#10; 55a:   8b 81 f4 ff ff ff       mov    -0xc(%ecx),%eax&#10; 560:   8b 55 08                mov    0x8(%ebp),%edx&#10; 563:   89 10                   mov    %edx,(%eax)&#10; 565:   5d                      pop    %ebp&#10; 566:   c3                      ret &#10;&#10;0000057f &#60;__x86.get_pc_thunk.cx&#62;:&#10; 57f:   8b 0c 24                mov    (%esp),%ecx&#10; 582:   c3                      ret    &#10; 583:   90                      nop</span><br></pre></td></tr></table></figure>
<ul>
<li>在 0x54f，call 了 <__x86.get_pc_thunk.cx>，ecx 的值會是0x554。</__x86.get_pc_thunk.cx></li>
<li>ecx 再加上 0x1aac，取得 GOT的位址(0x2000)。</li>
<li>ecx - 0xc 就是 _foo 的位址，被放到 eax裡。</li>
<li>在0x560，把 foo 的值放到 edx。</li>
<li>在0x563，更新 eax 位址的值為edx。</li>
</ul>
<p>使用 readelf 來看看 GOT 的位址
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readelf -S libfoo.so</span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  ...</span><br><span class="line">  [<span class="number">19</span>] .got              PROGBITS        <span class="number">00001</span>fe8 <span class="number">000</span>fe8 <span class="number">000018</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">20</span>] .got.plt          PROGBITS        <span class="number">00002000</span> <span class="number">001000</span> <span class="number">000014</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>這裡看到 0x2000 是 .got.plt 的位址，0x2000 - 0xc = 0x1ff4 為 _foo 的位址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">readelf -r libfoo.so</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">'.rel.dyn'</span> at offset <span class="number">0</span>x374 contains <span class="number">9</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">00001</span>ef4  <span class="number">00000008</span> R_386_RELATIVE   </span><br><span class="line"><span class="number">00001</span>ef8  <span class="number">00000008</span> R_386_RELATIVE   </span><br><span class="line"><span class="number">00002014</span>  <span class="number">00000008</span> R_386_RELATIVE   </span><br><span class="line"><span class="number">00001</span>fe8  <span class="number">00000106</span> R_386_GLOB_DAT    <span class="number">00000000</span>   _ITM_deregisterTMClone</span><br><span class="line"><span class="number">00001</span>fec  <span class="number">00000206</span> R_386_GLOB_DAT    <span class="number">00000000</span>   __cxa_finalize</span><br><span class="line"><span class="number">00001</span>ff0  <span class="number">00000306</span> R_386_GLOB_DAT    <span class="number">00000000</span>   __gmon_start__</span><br><span class="line"><span class="number">00001</span>ff4  <span class="number">00000</span>d06 R_386_GLOB_DAT    <span class="number">0000201</span>c   _foo</span><br></pre></td></tr></table></figure>
<h3 id="Function_calls_in_PIC">Function calls in PIC</h3><hr>
<ul>
<li>fPIC</li>
<li>fpic</li>
</ul>
<hr>
<p><a href="http://reborn2266.blogspot.tw/2011/11/position-independent-code-pic-in-shared.html" target="_blank" rel="external">PIC</a></p>
<p><a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/" target="_blank" rel="external">http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/</a>
<a href="https://wiki.gentoo.org/wiki/Hardened/Position_Independent_Code_internals" target="_blank" rel="external">https://wiki.gentoo.org/wiki/Hardened/Position_Independent_Code_internals</a>
<a href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" target="_blank" rel="external">http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/</a>
<a href="http://fcamel-life.blogspot.tw/2012/11/shared-library-visibility.html" target="_blank" rel="external">http://fcamel-life.blogspot.tw/2012/11/shared-library-visibility.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/06/15/fPIC/" data-id="ciho8m29r000943ifauetorrw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OSI-Model" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/05/25/OSI-Model/" class="article-date">
  <time datetime="2015-05-25T06:07:38.000Z" itemprop="datePublished">2015-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/05/25/OSI-Model/">OSI Model</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="OSI_level">OSI level</h3><ul>
<li>Layer 1 (Physical)<ul>
<li>USB, DSL...</li>
</ul>
</li>
<li>Layer 2 (Data Link)<ul>
<li>L2TP, IEEE 802.2...</li>
</ul>
</li>
<li>Layer 3 (Network Layer)<ul>
<li>IPv4, IPv6, ICMP, </li>
</ul>
</li>
<li>Layer 4 (Transport Layer)<ul>
<li>TCP, UDP</li>
</ul>
</li>
<li>Layer 5 (Session Layer)<ul>
<li>RPC, PAP</li>
</ul>
</li>
<li>Layer 6 (Presentation Layer)<ul>
<li>ASCII, JPEG, ...</li>
</ul>
</li>
<li>Layer 7 (Application Layer)<ul>
<li>HTTP, FTP, telnet</li>
</ul>
</li>
</ul>
<h3 id="ARP">ARP</h3><p>每個網卡都有個 48-bits 的 MAC address，區別各個網卡，但是上層的協定都是用 IP 來區別，因此需要一套方法對應 MAC 位址與 IP 位址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Address        HW<span class="built_in">type</span>    HWaddress           Flags Mask    Iface</span><br><span class="line"><span class="number">10.1</span>.<span class="number">9.43</span>      ether     <span class="number">10</span>:c3:<span class="number">7</span>b:b6:<span class="number">4</span>f:<span class="number">38</span>   C             enp0s25</span><br><span class="line"><span class="number">10.1</span>.<span class="number">9.130</span>     ether     <span class="number">00</span>:<span class="number">18</span>:<span class="number">1</span>a:f0:bf:e1   C             enp0s25</span><br><span class="line"><span class="number">192.168</span>.<span class="number">0.1</span>    ether     f4:ec:<span class="number">38</span>:e0:<span class="number">03</span>:<span class="number">92</span>   C             enp0s25</span><br><span class="line"><span class="number">10.1</span>.<span class="number">9.73</span>      ether     <span class="number">90</span>:<span class="number">2</span>b:<span class="number">34</span>:b7:<span class="number">10</span>:<span class="number">97</span>   C             enp0s25</span><br><span class="line"><span class="number">10.1</span>.<span class="number">9.254</span>     ether     <span class="number">00</span>:<span class="number">00</span>:<span class="number">0</span>c:<span class="number">07</span>:ac:<span class="number">09</span>   C             enp0s25</span><br><span class="line"><span class="number">10.1</span>.<span class="number">9.2</span>       ether     <span class="number">00</span>:<span class="number">24</span>:<span class="number">8</span>c:a6:<span class="number">67</span>:<span class="number">67</span>   C             enp0s25</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/05/25/OSI-Model/" data-id="ciho8m2a3000l43ifihf1zqcj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Network/">Network</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Memory-Management" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/04/30/Memory-Management/" class="article-date">
  <time datetime="2015-04-29T20:44:24.000Z" itemprop="datePublished">2015-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/04/30/Memory-Management/">Memory Management</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="MMU">MMU</h3><pre><code><span class="keyword">the</span> hardware <span class="keyword">that</span> manages memory <span class="keyword">and</span> performs virtual <span class="keyword">to</span> physical address
</code></pre><p>translations</p>
<h3 id="Page">Page</h3><p>page 是系統管理記憶體的最小單位，
Linux 將實體記憶體全部劃分為許多 page。
大多系統的 page size 為 4K</p>
<p>asm-generic/page.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef CONFIG_MMU</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">error</span> need to prove a real asm/page.h</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PAGE_SHIFT determines the page size */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PAGE_SHIFT	12</span></span><br><span class="line"><span class="preprocessor">#ifdef __ASSEMBLY__</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PAGE_SIZE	(1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PAGE_SIZE	(1UL &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PAGE_MASK	(~(PAGE_SIZE-1))</span></span><br></pre></td></tr></table></figure></p>
<p>linux/mm_types.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Each physical page in the system has a struct page associated with</span><br><span class="line"> * it to keep track of whatever it is we are using the page for at the</span><br><span class="line"> * moment. Note that we have no way to track which tasks are using</span><br><span class="line"> * a page, though if it is a pagecache page, rmap structures can tell us</span><br><span class="line"> * who is mapping it.</span><br><span class="line"> *</span><br><span class="line"> * The objects in struct page are organized in double word blocks in</span><br><span class="line"> * order to allows us to use atomic double word operations on portions</span><br><span class="line"> * of struct page. That is currently only used by slub but the arrangement</span><br><span class="line"> * allows the use of atomic double word operations on the flags/mapping</span><br><span class="line"> * and lru list pointers also.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> page &#123;</span><br><span class="line">	<span class="comment">/* First double word block */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;		<span class="comment">/* Atomic flags, some possibly</span><br><span class="line">					 * updated asynchronously */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> address_space *mapping;	<span class="comment">/* If low bit clear, points to</span><br><span class="line">						 * inode address_space, or NULL.</span><br><span class="line">						 * If page mapped as anonymous</span><br><span class="line">						 * memory, low bit is set, and</span><br><span class="line">						 * it points to anon_vma object:</span><br><span class="line">						 * see PAGE_MAPPING_ANON below.</span><br><span class="line">						 */</span></span><br><span class="line">		<span class="keyword">void</span> *s_mem;			<span class="comment">/* slab first object */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second double word */</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line">			pgoff_t index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">			<span class="keyword">void</span> *freelist;		<span class="comment">/* sl[aou]b first free object */</span></span><br><span class="line">			<span class="keyword">bool</span> pfmemalloc;	<span class="comment">/* If set by the page allocator,</span><br><span class="line">						 * ALLOC_NO_WATERMARKS was set</span><br><span class="line">						 * and the low watermark was not</span><br><span class="line">						 * met implying that the system</span><br><span class="line">						 * is under some pressure. The</span><br><span class="line">						 * caller should try ensure</span><br><span class="line">						 * this page is only used to</span><br><span class="line">						 * free other pages.</span><br><span class="line">						 */</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line">	defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span><br><span class="line">			<span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * Keep _count separate from slub cmpxchg_double data.</span><br><span class="line">			 * As the rest of the double word is protected by</span><br><span class="line">			 * slab_lock but _count is not.</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> counters;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">union</span> &#123;</span><br><span class="line">					<span class="comment">/*</span><br><span class="line">					 * Count of ptes mapped in</span><br><span class="line">					 * mms, to show when page is</span><br><span class="line">					 * mapped &amp; limit reverse map</span><br><span class="line">					 * searches.</span><br><span class="line">					 *</span><br><span class="line">					 * Used also for tail pages</span><br><span class="line">					 * refcounting instead of</span><br><span class="line">					 * _count. Tail pages cannot</span><br><span class="line">					 * be mapped and keeping the</span><br><span class="line">					 * tail page _count zero at</span><br><span class="line">					 * all times guarantees</span><br><span class="line">					 * get_page_unless_zero() will</span><br><span class="line">					 * never succeed on tail</span><br><span class="line">					 * pages.</span><br><span class="line">					 */</span></span><br><span class="line">					atomic_t _mapcount;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">struct</span> &#123; <span class="comment">/* SLUB */</span></span><br><span class="line">						<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">						<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">						<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">					&#125;;</span><br><span class="line">					<span class="keyword">int</span> units;	<span class="comment">/* SLOB */</span></span><br><span class="line">				&#125;;</span><br><span class="line">				atomic_t _count;		<span class="comment">/* Usage count, see below. */</span></span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> active;	<span class="comment">/* SLAB */</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Third double word block */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> list_head lru;	<span class="comment">/* Pageout list, eg. active_list</span><br><span class="line">					 * protected by zone-&gt;lru_lock !</span><br><span class="line">					 * Can be used as a generic list</span><br><span class="line">					 * by the page owner.</span><br><span class="line">					 */</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;		<span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">			<span class="keyword">struct</span> page *next;	<span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_64BIT</span></span><br><span class="line">			<span class="keyword">int</span> pages;	<span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">			<span class="keyword">int</span> pobjects;	<span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">			<span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">struct</span> slab *slab_page; <span class="comment">/* slab fields */</span></span><br><span class="line">		<span class="keyword">struct</span> rcu_head rcu_head;	<span class="comment">/* Used by SLAB</span><br><span class="line">						 * when destroying via RCU</span><br><span class="line">						 */</span></span><br><span class="line">		<span class="comment">/* First tail page of compound page */</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			compound_page_dtor *compound_dtor;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> compound_order;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">		pgtable_t pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;		<span class="comment">/* Mapping-private opaque data:</span><br><span class="line">					 	 * usually used for buffer_heads</span><br><span class="line">						 * if PagePrivate set; used for</span><br><span class="line">						 * swp_entry_t if PageSwapCache;</span><br><span class="line">						 * indicates order in the buddy</span><br><span class="line">						 * system if PG_buddy is set.</span><br><span class="line">						 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">		spinlock_t *ptl;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		spinlock_t ptl;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">struct</span> kmem_cache *slab_cache;	<span class="comment">/* SL[AU]B: Pointer to slab */</span></span><br><span class="line">		<span class="keyword">struct</span> page *first_page;	<span class="comment">/* Compound tail pages */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_MEMCG</span></span><br><span class="line">	<span class="keyword">struct</span> mem_cgroup *mem_cgroup;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * On machines where all RAM is mapped into kernel address space,</span><br><span class="line">	 * we can simply calculate the virtual address. On machines with</span><br><span class="line">	 * highmem some memory is mapped into kernel virtual memory</span><br><span class="line">	 * dynamically, so we need a place to store that address.</span><br><span class="line">	 * Note that this field could be 16 bits on x86 ... ;)</span><br><span class="line">	 *</span><br><span class="line">	 * Architectures with slow multiplication can define</span><br><span class="line">	 * WANT_PAGE_VIRTUAL in asm/page.h</span><br><span class="line">	 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">virtual</span>;			<span class="comment">/* Kernel virtual address (NULL if</span><br><span class="line">					   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* WANT_PAGE_VIRTUAL */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_KMEMCHECK</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * kmemcheck wants to track the status of each byte in a page; this</span><br><span class="line">	 * is a pointer to such a status block. NULL if not tracked.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">void</span> *shadow;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">	<span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * The struct page can be forced to be double word aligned so that atomic ops</span><br><span class="line"> * on double words work. The SLUB allocator can make use of such a feature.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_HAVE_ALIGNED_STRUCT_PAGE</span></span><br><span class="line">	__aligned(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>))</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br></pre></td></tr></table></figure></p>
<p>page 有個 flag 來表示狀態</p>
<p>linux/page-flags.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Various page-&gt;flags bits:</span><br><span class="line"> *</span><br><span class="line"> * PG_reserved is set for special pages, which can never be swapped out. Some</span><br><span class="line"> * of them might not even exist (eg empty_bad_page)...</span><br><span class="line"> *</span><br><span class="line"> * The PG_private bitflag is set on pagecache pages if they contain filesystem</span><br><span class="line"> * specific data (which is normally at page-&gt;private). It can be used by</span><br><span class="line"> * private allocations for its own usage.</span><br><span class="line"> *</span><br><span class="line"> * During initiation of disk I/O, PG_locked is set. This bit is set before I/O</span><br><span class="line"> * and cleared when writeback _starts_ or when read _completes_. PG_writeback</span><br><span class="line"> * is set before writeback starts and cleared when it finishes.</span><br><span class="line"> *</span><br><span class="line"> * PG_locked also pins a page in pagecache, and blocks truncation of the file</span><br><span class="line"> * while it is held.</span><br><span class="line"> *</span><br><span class="line"> * page_waitqueue(page) is a wait queue of all tasks waiting for the page</span><br><span class="line"> * to become unlocked.</span><br><span class="line"> *</span><br><span class="line"> * PG_uptodate tells whether the page's contents is valid.  When a read</span><br><span class="line"> * completes, the page becomes uptodate, unless a disk I/O error happened.</span><br><span class="line"> *</span><br><span class="line"> * PG_referenced, PG_reclaim are used for page reclaim for anonymous and</span><br><span class="line"> * file-backed pagecache (see mm/vmscan.c).</span><br><span class="line"> *</span><br><span class="line"> * PG_error is set to indicate that an I/O error occurred on this page.</span><br><span class="line"> *</span><br><span class="line"> * PG_arch_1 is an architecture specific page state bit.  The generic code</span><br><span class="line"> * guarantees that this bit is cleared for a page when it first is entered into</span><br><span class="line"> * the page cache.</span><br><span class="line"> *</span><br><span class="line"> * PG_highmem pages are not permanently mapped into the kernel virtual address</span><br><span class="line"> * space, they need to be kmapped separately for doing IO on the pages.  The</span><br><span class="line"> * struct page (these bits with information) are always mapped into kernel</span><br><span class="line"> * address space...</span><br><span class="line"> *</span><br><span class="line"> * PG_hwpoison indicates that a page got corrupted in hardware and contains</span><br><span class="line"> * data with incorrect ECC bits that triggered a machine check. Accessing is</span><br><span class="line"> * not safe since it may cause another machine check. Don't touch!</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Don't use the *_dontuse flags.  Use the macros.  Otherwise you'll break</span><br><span class="line"> * locked- and dirty-page accounting.</span><br><span class="line"> *</span><br><span class="line"> * The page flags field is split into two parts, the main flags area</span><br><span class="line"> * which extends from the low bits upwards, and the fields area which</span><br><span class="line"> * extends from the high bits downwards.</span><br><span class="line"> *</span><br><span class="line"> *  | FIELD | ... | FLAGS |</span><br><span class="line"> *  N-1           ^       0</span><br><span class="line"> *               (NR_PAGEFLAGS)</span><br><span class="line"> *</span><br><span class="line"> * The fields area is reserved for fields mapping zone, node (for NUMA) and</span><br><span class="line"> * SPARSEMEM section (for variants of SPARSEMEM that require section ids like</span><br><span class="line"> * SPARSEMEM_EXTREME with !SPARSEMEM_VMEMMAP).</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">enum</span> pageflags &#123;</span><br><span class="line">	PG_locked,		<span class="comment">/* Page is locked. Don't touch. */</span></span><br><span class="line">	PG_error,</span><br><span class="line">	PG_referenced,</span><br><span class="line">	PG_uptodate,</span><br><span class="line">	PG_dirty,</span><br><span class="line">	PG_lru,</span><br><span class="line">	PG_active,</span><br><span class="line">	PG_slab,</span><br><span class="line">	PG_owner_priv_1,	<span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">	PG_arch_1,</span><br><span class="line">	PG_reserved,</span><br><span class="line">	PG_private,		<span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">	PG_private_2,		<span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">	PG_writeback,		<span class="comment">/* Page is under writeback */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PAGEFLAGS_EXTENDED</span></span><br><span class="line">	PG_head,		<span class="comment">/* A head page */</span></span><br><span class="line">	PG_tail,		<span class="comment">/* A tail page */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	PG_compound,		<span class="comment">/* A compound page */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	PG_swapcache,		<span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line">	PG_mappedtodisk,	<span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">	PG_reclaim,		<span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">	PG_swapbacked,		<span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">	PG_unevictable,		<span class="comment">/* Page is "unevictable"  */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_MMU</span></span><br><span class="line">	PG_mlocked,		<span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">	PG_uncached,		<span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_MEMORY_FAILURE</span></span><br><span class="line">	PG_hwpoison,		<span class="comment">/* hardware poisoned page. Don't touch */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	PG_compound_lock,</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	__NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Filesystems */</span></span><br><span class="line">	PG_checked = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span><br><span class="line">	 * state.  These bits are set on pages belonging to the netfs's inodes</span><br><span class="line">	 * when those inodes are being locally cached.</span><br><span class="line">	 */</span></span><br><span class="line">	PG_fscache = PG_private_2,	<span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XEN */</span></span><br><span class="line">	<span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">	PG_pinned = PG_owner_priv_1,</span><br><span class="line">	<span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">	PG_savepinned = PG_dirty,</span><br><span class="line">	<span class="comment">/* Has a grant mapping of another (foreign) domain's page. */</span></span><br><span class="line">	PG_foreign = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SLOB */</span></span><br><span class="line">	PG_slob_free = PG_private,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>atomic_t _count 計算該 page 的 usage count
這個counter不能直接讀取，要透過 page_count()</p>
<p>linux/mm.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">page_count</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> atomic_read(&amp;compound_head(page)-&gt;_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>void *virtual 則是 page的 virtual memory address
但是有些 page 不會一直 mapping 到 kernel，此時 virtual = NULL</p>
<h3 id="Zones">Zones</h3><ul>
<li>ZONE_DMA
This zone contains pages that can undergo DMA.</li>
<li>ZONE_DMA_32
Like ZOME_DMA, this zone contains pages that can undergo DMA.
Unlike ZONE_DMA, these pages are accessible only by 32-bit devices. On some architectures,
this zone is a larger subset of memory.</li>
<li>ZONE_NORMAL
This zone contains normal, regularly mapped, pages.</li>
<li>ZONE_HIGHMEM
This zone contains “high memory,” which are pages not permanently
mapped into the kernel’s address space.</li>
</ul>
<p>linux/mmzone.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> zone_type &#123;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_ZONE_DMA</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * ZONE_DMA is used when there are devices that are not able</span><br><span class="line">	 * to do DMA to all of addressable memory (ZONE_NORMAL). Then we</span><br><span class="line">	 * carve out the portion of memory that is needed for these devices.</span><br><span class="line">	 * The range is arch specific.</span><br><span class="line">	 *</span><br><span class="line">	 * Some examples</span><br><span class="line">	 *</span><br><span class="line">	 * Architecture		Limit</span><br><span class="line">	 * ---------------------------</span><br><span class="line">	 * parisc, ia64, sparc	&lt;4G</span><br><span class="line">	 * s390			&lt;2G</span><br><span class="line">	 * arm			Various</span><br><span class="line">	 * alpha		Unlimited or 0-16MB.</span><br><span class="line">	 *</span><br><span class="line">	 * i386, x86_64 and multiple other arches</span><br><span class="line">	 * 			&lt;16M.</span><br><span class="line">	 */</span></span><br><span class="line">	ZONE_DMA,</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_ZONE_DMA32</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * x86_64 needs two ZONE_DMAs because it supports devices that are</span><br><span class="line">	 * only able to do DMA to the lower 16M but also 32 bit devices that</span><br><span class="line">	 * can only do DMA areas below 4G.</span><br><span class="line">	 */</span></span><br><span class="line">	ZONE_DMA32,</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span><br><span class="line">	 * performed on pages in ZONE_NORMAL if the DMA devices support</span><br><span class="line">	 * transfers to all addressable memory.</span><br><span class="line">	 */</span></span><br><span class="line">	ZONE_NORMAL,</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_HIGHMEM</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * A memory area that is only addressable by the kernel through</span><br><span class="line">	 * mapping portions into its own address space. This is for example</span><br><span class="line">	 * used by i386 to allow the kernel to address the memory beyond</span><br><span class="line">	 * 900MB. The kernel will set up special mappings (page</span><br><span class="line">	 * table entries on i386) for each page that the kernel needs to</span><br><span class="line">	 * access.</span><br><span class="line">	 */</span></span><br><span class="line">	ZONE_HIGHMEM,</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	ZONE_MOVABLE,</span><br><span class="line">	__MAX_NR_ZONES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Zone Description Physical Memory
ZONE_DMA DMA-able pages &lt; 16MB
ZONE_NORMAL Normally addressable pages 16–896MB
ZONE_HIGHMEM Dynamically mapped pages &gt; 896MB</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/04/30/Memory-Management/" data-id="ciho8m28t000043if4edfuhgm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Multiple-of-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/04/29/Multiple-of-3/" class="article-date">
  <time datetime="2015-04-29T15:40:29.000Z" itemprop="datePublished">2015-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/04/29/Multiple-of-3/">Multiple of 3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>利用位數累加的方式，可以推算出 mod 值。</p>
<p>0xABCD mod 3 = (A <em> 0xFFF ＋ B </em> 0xFF + C * 0xF) mod 3
    = (A + B + C) mod 3</p>
<p>最後計算出餘數再直接判斷。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_mod3</span><span class="params">(__u32 x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">	result = (x &amp; <span class="number">0xf</span>) +</span><br><span class="line">		((x &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>) +</span><br><span class="line">		((x &amp; <span class="number">0xf00</span>) &gt;&gt; <span class="number">8</span>) +</span><br><span class="line">		((x &amp; <span class="number">0xf000</span>) &gt;&gt; <span class="number">12</span>) +</span><br><span class="line">		((x &amp; <span class="number">0xf0000</span>) &gt;&gt; <span class="number">16</span>) +</span><br><span class="line">		((x &amp; <span class="number">0xf00000</span>) &gt;&gt; <span class="number">20</span>) +</span><br><span class="line">		((x &amp; <span class="number">0xf000000</span>) &gt;&gt; <span class="number">24</span>) +</span><br><span class="line">		((x &amp; <span class="number">0xf0000000</span>) &gt;&gt; <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(result &gt; <span class="number">0xf</span>) &#123;</span><br><span class="line">		result = (result &amp; <span class="number">0xf</span>) +</span><br><span class="line">			((result &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(result) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/04/29/Multiple-of-3/" data-id="ciho8m2a6000o43ifjxmvhvuq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Thread-in-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/04/22/Thread-in-Linux/" class="article-date">
  <time datetime="2015-04-22T05:27:45.000Z" itemprop="datePublished">2015-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/04/22/Thread-in-Linux/">Thread in Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Linux uses a 1-1 threading model, with (to the kernel) no distinction between processes and threads
-- everything is simply a runnable task. *</p>
<p>On Linux, the system call clone clones a task, with a configurable level of sharing, among which are:</p>
<ul>
<li>CLONE_FILES: share the same file descriptor table (instead of creating a copy)</li>
<li>CLONE_PARENT: don&#39;t set up a parent-child relationship between the new task and the old
(otherwise, child&#39;s getppid() = parent&#39;s getpid())
+CLONE_VM: share the same memory space (instead of creating a COW copy)
fork() calls clone(least sharing) and pthread_create() calls clone(most sharing). **</li>
</ul>
<p>forking costs a tiny bit more than pthread_createing because of copying tables and creating COW mappings for memory,
but the Linux kernel developers have tried (and succeeded) at minimizing those costs.</p>
<p>Switching between tasks, if they share the same memory space and various tables, will be a tiny bit cheaper
than if they aren&#39;t shared, because the data may already be loaded in cache. However,
switching tasks is still very fast even if nothing is shared -- this is something else that Linux kernel developers
try to ensure (and succeed at ensuring).</p>
<p>In fact, if you are on a multi-processor system, not sharing may actually be a performance boon:
if each task is running on a different processor, synchronizing shared memory is expensive.</p>
<h3 id="Creating_Threads">Creating Threads</h3><p>linux/kthread.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *kthread_create_on_node(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data),</span><br><span class="line">					   <span class="keyword">void</span> *data,</span><br><span class="line">					   <span class="keyword">int</span> node,</span><br><span class="line">					   <span class="keyword">const</span> <span class="keyword">char</span> namefmt[], ...);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kthread_create(threadfn, data, namefmt, arg...) \</span></span><br><span class="line">	kthread_create_on_node(threadfn, data, -<span class="number">1</span>, namefmt, <span class="preprocessor">##arg)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> task_struct *kthread_create_on_cpu(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data),</span><br><span class="line">					  <span class="keyword">void</span> *data,</span><br><span class="line">					  <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu,</span><br><span class="line">					  <span class="keyword">const</span> <span class="keyword">char</span> *namefmt);</span><br></pre></td></tr></table></figure></p>
<p>kthread_create_on_cpu 會綁在指定的 cpu 上</p>
<p>接著看看 kthread_create_on_node()的實作</p>
<p>kernel/kthread.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * kthread_create_on_node - create a kthread.</span><br><span class="line"> * @threadfn: the function to run until signal_pending(current).</span><br><span class="line"> * @data: data ptr for @threadfn.</span><br><span class="line"> * @node: memory node number.</span><br><span class="line"> * @namefmt: printf-style name for the thread.</span><br><span class="line"> *</span><br><span class="line"> * Description: This helper function creates and names a kernel</span><br><span class="line"> * thread.  The thread will be stopped: use wake_up_process() to start</span><br><span class="line"> * it.  See also kthread_run().</span><br><span class="line"> *</span><br><span class="line"> * If thread is going to be bound on a particular cpu, give its node</span><br><span class="line"> * in @node, to get NUMA affinity for kthread stack, or else give -1.</span><br><span class="line"> * When woken, the thread will run @threadfn() with @data as its</span><br><span class="line"> * argument. @threadfn() can either call do_exit() directly if it is a</span><br><span class="line"> * standalone thread for which no one will call kthread_stop(), or</span><br><span class="line"> * return when 'kthread_should_stop()' is true (which means</span><br><span class="line"> * kthread_stop() has been called).  The return value should be zero</span><br><span class="line"> * or a negative error number; it will be passed to kthread_stop().</span><br><span class="line"> *</span><br><span class="line"> * Returns a task_struct or ERR_PTR(-ENOMEM) or ERR_PTR(-EINTR).</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *kthread_create_on_node(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data),</span><br><span class="line">					   <span class="keyword">void</span> *data, <span class="keyword">int</span> node,</span><br><span class="line">					   <span class="keyword">const</span> <span class="keyword">char</span> namefmt[],</span><br><span class="line">					   ...)</span><br><span class="line">&#123;</span><br><span class="line">	DECLARE_COMPLETION_ONSTACK(done);</span><br><span class="line">	<span class="keyword">struct</span> task_struct *task;</span><br><span class="line">	<span class="keyword">struct</span> kthread_create_info *create = kmalloc(<span class="keyword">sizeof</span>(*create),</span><br><span class="line">						     GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!create)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	create-&gt;threadfn = threadfn;</span><br><span class="line">	create-&gt;data = data;</span><br><span class="line">	create-&gt;node = node;</span><br><span class="line">	create-&gt;done = &amp;done;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;kthread_create_lock);</span><br><span class="line">	list_add_tail(&amp;create-&gt;<span class="built_in">list</span>, &amp;kthread_create_list);</span><br><span class="line">	spin_unlock(&amp;kthread_create_lock);</span><br><span class="line"></span><br><span class="line">	wake_up_process(kthreadd_task);</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Wait for completion in killable state, for I might be chosen by</span><br><span class="line">	 * the OOM killer while kthreadd is trying to allocate memory for</span><br><span class="line">	 * new kernel thread.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(wait_for_completion_killable(&amp;done))) &#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * If I was SIGKILLed before kthreadd (or new kernel thread)</span><br><span class="line">		 * calls complete(), leave the cleanup of this structure to</span><br><span class="line">		 * that thread.</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (xchg(&amp;create-&gt;done, NULL))</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-EINTR);</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * kthreadd (or new kernel thread) will call complete()</span><br><span class="line">		 * shortly.</span><br><span class="line">		 */</span></span><br><span class="line">		wait_for_completion(&amp;done);</span><br><span class="line">	&#125;</span><br><span class="line">	task = create-&gt;result;</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(task)) &#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> sched_param param = &#123; .sched_priority = <span class="number">0</span> &#125;;</span><br><span class="line">		va_list args;</span><br><span class="line"></span><br><span class="line">		va_start(args, namefmt);</span><br><span class="line">		vsnprintf(task-&gt;comm, <span class="keyword">sizeof</span>(task-&gt;comm), namefmt, args);</span><br><span class="line">		va_end(args);</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * root may have changed our (kthreadd's) priority or CPU mask.</span><br><span class="line">		 * The kernel thread should not inherit these properties.</span><br><span class="line">		 */</span></span><br><span class="line">		sched_setscheduler_nocheck(task, SCHED_NORMAL, &amp;param);</span><br><span class="line">		set_cpus_allowed_ptr(task, cpu_all_mask);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(create);</span><br><span class="line">	<span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kthread_create_on_node);</span><br></pre></td></tr></table></figure></p>
<p>kthread_create_on_node() 會產生一個 kthread_info，丟到 kthread_create_list，
wake up kthreadd_task，由 kthreadd() 這個 kthread 來 create kthread。</p>
<p>kernel/kthread.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthreadd</span><span class="params">(<span class="keyword">void</span> *unused)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct *tsk = current;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup a clean context for our children to inherit. */</span></span><br><span class="line">	set_task_comm(tsk, <span class="string">"kthreadd"</span>);</span><br><span class="line">	ignore_signals(tsk);</span><br><span class="line">	set_cpus_allowed_ptr(tsk, cpu_all_mask);</span><br><span class="line">	set_mems_allowed(node_states[N_MEMORY]);</span><br><span class="line"></span><br><span class="line">	current-&gt;flags |= PF_NOFREEZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">		<span class="keyword">if</span> (list_empty(&amp;kthread_create_list))</span><br><span class="line">			schedule();</span><br><span class="line">		__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;kthread_create_lock);</span><br><span class="line">		<span class="keyword">while</span> (!list_empty(&amp;kthread_create_list)) &#123;</span><br><span class="line">			<span class="keyword">struct</span> kthread_create_info *create;</span><br><span class="line"></span><br><span class="line">			create = list_entry(kthread_create_list.next,</span><br><span class="line">					    <span class="keyword">struct</span> kthread_create_info, <span class="built_in">list</span>);</span><br><span class="line">			list_del_init(&amp;create-&gt;<span class="built_in">list</span>);</span><br><span class="line">			spin_unlock(&amp;kthread_create_lock);</span><br><span class="line"></span><br><span class="line">			create_kthread(create);</span><br><span class="line"></span><br><span class="line">			spin_lock(&amp;kthread_create_lock);</span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_kthread</span><span class="params">(<span class="keyword">struct</span> kthread_create_info *create)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_NUMA</span></span><br><span class="line">	current-&gt;pref_node_fork = create-&gt;node;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* We want our own signal handler (we take no signals by default). */</span></span><br><span class="line">	pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* If user was SIGKILLed, I release the structure. */</span></span><br><span class="line">		<span class="keyword">struct</span> completion *done = xchg(&amp;create-&gt;done, NULL);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!done) &#123;</span><br><span class="line">			kfree(create);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		create-&gt;result = ERR_PTR(pid);</span><br><span class="line">		complete(done);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthread</span><span class="params">(<span class="keyword">void</span> *_create)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* Copy data: it's on kthread's stack */</span></span><br><span class="line">	<span class="keyword">struct</span> kthread_create_info *create = _create;</span><br><span class="line">	<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data) = create-&gt;threadfn;</span><br><span class="line">	<span class="keyword">void</span> *data = create-&gt;data;</span><br><span class="line">	<span class="keyword">struct</span> completion *done;</span><br><span class="line">	<span class="keyword">struct</span> kthread self;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	self.flags = <span class="number">0</span>;</span><br><span class="line">	self.data = data;</span><br><span class="line">	init_completion(&amp;self.exited);</span><br><span class="line">	init_completion(&amp;self.parked);</span><br><span class="line">	current-&gt;vfork_done = &amp;self.exited;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If user was SIGKILLed, I release the structure. */</span></span><br><span class="line">	done = xchg(&amp;create-&gt;done, NULL);</span><br><span class="line">	<span class="keyword">if</span> (!done) &#123;</span><br><span class="line">		kfree(create);</span><br><span class="line">		do_exit(-EINTR);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* OK, tell user we're spawned, wait for stop or wakeup */</span></span><br><span class="line">	__set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">	create-&gt;result = current;</span><br><span class="line">	complete(done);</span><br><span class="line">	schedule();</span><br><span class="line"></span><br><span class="line">	ret = -EINTR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!test_bit(KTHREAD_SHOULD_STOP, &amp;self.flags)) &#123;</span><br><span class="line">		__kthread_parkme(&amp;self);</span><br><span class="line">		ret = threadfn(data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* we can't just return, we must preserve "self" on stack */</span></span><br><span class="line">	do_exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>kthreadd() 從 list 拿到 kthread_create_info, 丟給 create_kthread()，
然後用預先定義好的 kthread stack, kthread 丟給 kernel_thread()，讓 kernel do_fork。
，在 kthread 可以看到它呼叫 threadfn(data); 就是 kthread_create_info 裡的 func。</p>
<p>create_kthread() 的參數為 kthread_create_info，pass到 kernel_thread 的 第二個參數。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pid_t <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)</span><span class="params">(<span class="keyword">void</span> *)</span>, <span class="keyword">void</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> do_fork(flags|CLONE_VM|CLONE_UNTRACED, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fn,</span><br><span class="line">		(<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那 kthreadd_task 又是怎麼 create 的？
init/main.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __<span class="function">init_refok <span class="title">rest_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">	rcu_scheduler_starting();</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * We need to spawn init first so that it obtains pid 1, however</span><br><span class="line">	 * the init task will end up wanting to create kthreads, which, if</span><br><span class="line">	 * we schedule it before we create kthreadd, will OOPS.</span><br><span class="line">	 */</span></span><br><span class="line">	kernel_thread(kernel_init, NULL, CLONE_FS);</span><br><span class="line">	numa_default_policy();</span><br><span class="line">	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	complete(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * The boot idle thread must execute schedule()</span><br><span class="line">	 * at least once to get things moving:</span><br><span class="line">	 */</span></span><br><span class="line">	init_idle_bootup_task(current);</span><br><span class="line">	schedule_preempt_disabled();</span><br><span class="line">	<span class="comment">/* Call into cpu_idle with preempt disabled */</span></span><br><span class="line">	cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Linux 提供一個 kthread_run 的 macro
把 kthread_create 和 wake_up_process() 包在一起。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * kthread_run - create and wake a thread.</span><br><span class="line"> * @threadfn: the function to run until signal_pending(current).</span><br><span class="line"> * @data: data ptr for @threadfn.</span><br><span class="line"> * @namefmt: printf-style name for the thread.</span><br><span class="line"> *</span><br><span class="line"> * Description: Convenient wrapper for kthread_create() followed by</span><br><span class="line"> * wake_up_process().  Returns the kthread or ERR_PTR(-ENOMEM).</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kthread_run(threadfn, data, namefmt, ...)			   \</span></span><br><span class="line">(&#123;									   \</span><br><span class="line">	<span class="keyword">struct</span> task_struct *__k						   \</span><br><span class="line">		= kthread_create(threadfn, data, namefmt, <span class="preprocessor">## __VA_ARGS__); \</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(__k))						   \</span><br><span class="line">		wake_up_process(__k);					   \</span><br><span class="line">	__k;								   \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/04/22/Thread-in-Linux/" data-id="ciho8m29v000c43if0us1wvot" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-PER-CPU" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/04/21/PER-CPU/" class="article-date">
  <time datetime="2015-04-21T09:11:32.000Z" itemprop="datePublished">2015-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/04/21/PER-CPU/">PER_CPU</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Per-CPU variable，就是在每個 cpu cache 上都存一份，存取不需要 lock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;linux/percpu.h&gt;</span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU(type, name);</span><br></pre></td></tr></table></figure>
<p>以 softirq 的例子來說明</p>
<p>kernel/softirq.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(<span class="keyword">struct</span> task_struct *, ksoftirqd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> softirq_to_name[NR_SOFTIRQS] = &#123;</span><br><span class="line">	<span class="string">"HI"</span>, <span class="string">"TIMER"</span>, <span class="string">"NET_TX"</span>, <span class="string">"NET_RX"</span>, <span class="string">"BLOCK"</span>, <span class="string">"BLOCK_IOPOLL"</span>,</span><br><span class="line">	<span class="string">"TASKLET"</span>, <span class="string">"SCHED"</span>, <span class="string">"HRTIMER"</span>, <span class="string">"RCU"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * we cannot loop indefinitely here to avoid userspace starvation,</span><br><span class="line"> * but we also don't want to introduce a worst case 1/HZ latency</span><br><span class="line"> * to the pending events, so lets the scheduler to balance</span><br><span class="line"> * the softirq load for us.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wakeup_softirqd</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* Interrupts are disabled: no need to stop preemption */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *tsk = __this_cpu_read(ksoftirqd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tsk &amp;&amp; tsk-&gt;state != TASK_RUNNING)</span><br><span class="line">		wake_up_process(tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>linux/interrupt.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_PER_CPU(<span class="keyword">struct</span> task_struct *, ksoftirqd);</span><br></pre></td></tr></table></figure></p>
<p>Per-CPU 變數存放的地方在哪宣告呢，下面看看 asm-gemeric/percpu.h
asm-generic/percpu.h
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * per_cpu_offset() is the offset that has to be added to a</span><br><span class="line"> * percpu variable to get to the instance for a certain processor.</span><br><span class="line"> *</span><br><span class="line"> * Most arches use the __per_cpu_offset array for those offsets but</span><br><span class="line"> * some arches have their own ways of determining the offset (x86_64, s390).</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#ifndef __per_cpu_offset</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __per_cpu_offset[NR_CPUS];</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> per_cpu_offset(x) (__per_cpu_offset[x])</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Determine the offset for the currently active processor.</span><br><span class="line"> * An arch may define __my_cpu_offset to provide a more effective</span><br><span class="line"> * means of obtaining the offset to the per cpu variables of the</span><br><span class="line"> * current processor.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#ifndef __my_cpu_offset</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __my_cpu_offset per_cpu_offset(raw_smp_processor_id())</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_DEBUG_PREEMPT</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> my_cpu_offset per_cpu_offset(smp_processor_id())</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> my_cpu_offset __my_cpu_offset</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Arch may define arch_raw_cpu_ptr() to provide more efficient address</span><br><span class="line"> * translations for raw_cpu_ptr().</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#ifndef arch_raw_cpu_ptr</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> arch_raw_cpu_ptr(ptr) SHIFT_PERCPU_PTR(ptr, __my_cpu_offset)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_HAVE_SETUP_PER_CPU_AREA</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">setup_per_cpu_areas</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span>	/* SMP */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifndef PER_CPU_BASE_SECTION</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_SMP</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PER_CPU_BASE_SECTION ".data..percpu"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PER_CPU_BASE_SECTION ".data"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifndef PER_CPU_ATTRIBUTES</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PER_CPU_ATTRIBUTES</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifndef PER_CPU_DEF_ATTRIBUTES</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PER_CPU_DEF_ATTRIBUTES</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>看到PER_CPU_BASE_SECTION，定義了 section 位置 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/04/21/PER-CPU/" data-id="ciho8m2a0000j43ife4zji6i8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Process-Creation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/04/15/Process-Creation/" class="article-date">
  <time datetime="2015-04-15T15:00:04.000Z" itemprop="datePublished">2015-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/04/15/Process-Creation/">Process Creation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Process">Process</h3><p>Processes are, however, more than just the executing program code (often called the text section in Unix).They also include a set of resources such as open files and pending signals, internal kernel data, processor state, a memory address space with one or more memory mappings, one or more threads of execution, and a data section containing global variables. 
Processes, in effect, are the living result of running program code.The kernel needs to manage all these details efficiently and transparently. Threads of execution, often shortened to thread</p>
<p><a href="https://kerker-notes.hackpad.com/process-thread-9UEQ2LVPjzv" target="_blank" rel="external">Process and Thread in Linux</a></p>
<h3 id="Process_Descriptor">Process Descriptor</h3><p>Linux 把 process 存放在一個 circual doubly linked list
, task list，process則是有個 Process Descriptor(PCB)來紀錄 process的資訊，在Linux裡叫 struct task_struct。下面來看看 task_struct長怎樣。
defined in
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;linux/sched.h&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">	atomic_t usage;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;	<span class="comment">/* per process flags, defined below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">struct</span> llist_node wake_entry;</span><br><span class="line">	<span class="keyword">int</span> on_cpu;</span><br><span class="line">	<span class="keyword">struct</span> task_struct *last_wakee;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> wakee_flips;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> wakee_flip_decay_ts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> wake_cpu;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> on_rq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> prio, static_prio, normal_prio;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> sched_class *sched_class;</span><br><span class="line">	<span class="keyword">struct</span> sched_entity se;</span><br><span class="line">	<span class="keyword">struct</span> sched_rt_entity rt;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_CGROUP_SCHED</span></span><br><span class="line">	<span class="keyword">struct</span> task_group *sched_task_group;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> sched_dl_entity dl;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	<span class="comment">/* list of struct preempt_notifier: */</span></span><br><span class="line">	<span class="keyword">struct</span> hlist_head preempt_notifiers;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> btrace_seq;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line">	<span class="keyword">int</span> nr_cpus_allowed;</span><br><span class="line">	cpumask_t cpus_allowed;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PREEMPT_RCU</span></span><br><span class="line">	<span class="keyword">int</span> rcu_read_lock_nesting;</span><br><span class="line">	<span class="keyword">union</span> rcu_special rcu_read_unlock_special;</span><br><span class="line">	<span class="keyword">struct</span> list_head rcu_node_entry;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* #ifdef CONFIG_PREEMPT_RCU */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PREEMPT_RCU</span></span><br><span class="line">	<span class="keyword">struct</span> rcu_node *rcu_blocked_node;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* #ifdef CONFIG_PREEMPT_RCU */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_TASKS_RCU</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rcu_tasks_nvcsw;</span><br><span class="line">	<span class="keyword">bool</span> rcu_tasks_holdout;</span><br><span class="line">	<span class="keyword">struct</span> list_head rcu_tasks_holdout_list;</span><br><span class="line">	<span class="keyword">int</span> rcu_tasks_idle_cpu;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* #ifdef CONFIG_TASKS_RCU */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span></span><br><span class="line">	<span class="keyword">struct</span> sched_info sched_info;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> list_head tasks;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">struct</span> plist_node pushable_tasks;</span><br><span class="line">	<span class="keyword">struct</span> rb_node pushable_dl_tasks;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> mm_struct *mm, *active_mm;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_COMPAT_BRK</span></span><br><span class="line">	<span class="keyword">unsigned</span> brk_randomized:<span class="number">1</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* per-thread vma caching */</span></span><br><span class="line">	u32 vmacache_seqnum;</span><br><span class="line">	<span class="keyword">struct</span> vm_area_struct *vmacache[VMACACHE_SIZE];</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(SPLIT_RSS_COUNTING)</span></span><br><span class="line">	<span class="keyword">struct</span> task_rss_stat	rss_stat;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* task state */</span></span><br><span class="line">	<span class="keyword">int</span> exit_state;</span><br><span class="line">	<span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line">	<span class="keyword">int</span> pdeath_signal;  <span class="comment">/*  The signal sent when the parent dies  */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> jobctl;	<span class="comment">/* JOBCTL_*, siglock protected */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Used for emulating ABI behavior of previous Linux versions */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> personality;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> in_execve:<span class="number">1</span>;	<span class="comment">/* Tell the LSMs that the process is doing an</span><br><span class="line">				 * execve */</span></span><br><span class="line">	<span class="keyword">unsigned</span> in_iowait:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Revert to default priority/policy when forking */</span></span><br><span class="line">	<span class="keyword">unsigned</span> sched_reset_on_fork:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> sched_contributes_to_load:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_MEMCG_KMEM</span></span><br><span class="line">	<span class="keyword">unsigned</span> memcg_kmem_skip_account:<span class="number">1</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> atomic_flags; <span class="comment">/* Flags needing atomic access. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> restart_block restart_block;</span><br><span class="line"></span><br><span class="line">	pid_t pid;</span><br><span class="line">	pid_t tgid;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_CC_STACKPROTECTOR</span></span><br><span class="line">	<span class="comment">/* Canary value for the -fstack-protector gcc feature */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_canary;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * pointers to (original) parent process, youngest child, younger sibling,</span><br><span class="line">	 * older sibling, respectively.  (p-&gt;father can be replaced with</span><br><span class="line">	 * p-&gt;real_parent-&gt;pid)</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct __rcu *real_parent; <span class="comment">/* real parent process */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct __rcu *parent; <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * children/sibling forms the list of my natural children</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head children;	<span class="comment">/* list of my children */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head sibling;	<span class="comment">/* linkage in my parent's children list */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *group_leader;	<span class="comment">/* threadgroup leader */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * ptraced is the list of tasks this task is using ptrace on.</span><br><span class="line">	 * This includes both natural children and PTRACE_ATTACH targets.</span><br><span class="line">	 * p-&gt;ptrace_entry is p's link on the p-&gt;parent-&gt;ptraced list.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head ptraced;</span><br><span class="line">	<span class="keyword">struct</span> list_head ptrace_entry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PID/PID hash table linkage. */</span></span><br><span class="line">	<span class="keyword">struct</span> pid_link pids[PIDTYPE_MAX];</span><br><span class="line">	<span class="keyword">struct</span> list_head thread_group;</span><br><span class="line">	<span class="keyword">struct</span> list_head thread_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> completion *vfork_done;		<span class="comment">/* for vfork() */</span></span><br><span class="line">	<span class="keyword">int</span> __user *set_child_tid;		<span class="comment">/* CLONE_CHILD_SETTID */</span></span><br><span class="line">	<span class="keyword">int</span> __user *clear_child_tid;		<span class="comment">/* CLONE_CHILD_CLEARTID */</span></span><br><span class="line"></span><br><span class="line">	cputime_t utime, stime, utimescaled, stimescaled;</span><br><span class="line">	cputime_t gtime;</span><br><span class="line"><span class="preprocessor">#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE</span></span><br><span class="line">	<span class="keyword">struct</span> cputime prev_cputime;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line">	seqlock_t vtime_seqlock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> vtime_snap;</span><br><span class="line">	<span class="keyword">enum</span> &#123;</span><br><span class="line">		VTIME_SLEEPING = <span class="number">0</span>,</span><br><span class="line">		VTIME_USER,</span><br><span class="line">		VTIME_SYS,</span><br><span class="line">	&#125; vtime_snap_whence;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nvcsw, nivcsw; <span class="comment">/* context switch counts */</span></span><br><span class="line">	u64 start_time;		<span class="comment">/* monotonic time in nsec */</span></span><br><span class="line">	u64 real_start_time;	<span class="comment">/* boot based time in nsec */</span></span><br><span class="line"><span class="comment">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> task_cputime cputime_expires;</span><br><span class="line">	<span class="keyword">struct</span> list_head cpu_timers[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> cred __rcu *real_cred; <span class="comment">/* objective and real subjective task</span><br><span class="line">					 * credentials (COW) */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> cred __rcu *cred;	<span class="comment">/* effective (overridable) subjective task</span><br><span class="line">					 * credentials (COW) */</span></span><br><span class="line">	<span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span><br><span class="line">				     - access with [gs]et_task_comm (which lock</span><br><span class="line">				       it with task_lock())</span><br><span class="line">				     - initialized normally by setup_new_exec */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">	<span class="keyword">int</span> link_count, total_link_count;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_SYSVIPC</span></span><br><span class="line"><span class="comment">/* ipc stuff */</span></span><br><span class="line">	<span class="keyword">struct</span> sysv_sem sysvsem;</span><br><span class="line">	<span class="keyword">struct</span> sysv_shm sysvshm;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line"><span class="comment">/* hung task detection */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> last_switch_count;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">	<span class="keyword">struct</span> thread_struct thread;</span><br><span class="line"><span class="comment">/* filesystem information */</span></span><br><span class="line">	<span class="keyword">struct</span> fs_struct *fs;</span><br><span class="line"><span class="comment">/* open file information */</span></span><br><span class="line">	<span class="keyword">struct</span> files_struct *files;</span><br><span class="line"><span class="comment">/* namespaces */</span></span><br><span class="line">	<span class="keyword">struct</span> nsproxy *nsproxy;</span><br><span class="line"><span class="comment">/* signal handlers */</span></span><br><span class="line">	<span class="keyword">struct</span> signal_struct *signal;</span><br><span class="line">	<span class="keyword">struct</span> sighand_struct *sighand;</span><br><span class="line"></span><br><span class="line">	sigset_t blocked, real_blocked;</span><br><span class="line">	sigset_t saved_sigmask;	<span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line">	<span class="keyword">struct</span> sigpending pending;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line">	size_t sas_ss_size;</span><br><span class="line">	<span class="keyword">int</span> (*notifier)(<span class="keyword">void</span> *priv);</span><br><span class="line">	<span class="keyword">void</span> *notifier_data;</span><br><span class="line">	sigset_t *notifier_mask;</span><br><span class="line">	<span class="keyword">struct</span> callback_head *task_works;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> audit_context *audit_context;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_AUDITSYSCALL</span></span><br><span class="line">	kuid_t loginuid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sessionid;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> seccomp seccomp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread group tracking */</span></span><br><span class="line">   	u32 parent_exec_id;</span><br><span class="line">   	u32 self_exec_id;</span><br><span class="line"><span class="comment">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed,</span><br><span class="line"> * mempolicy */</span></span><br><span class="line">	spinlock_t alloc_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Protection of the PI data structures: */</span></span><br><span class="line">	raw_spinlock_t pi_lock;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_RT_MUTEXES</span></span><br><span class="line">	<span class="comment">/* PI waiters blocked on a rt_mutex held by this task */</span></span><br><span class="line">	<span class="keyword">struct</span> rb_root pi_waiters;</span><br><span class="line">	<span class="keyword">struct</span> rb_node *pi_waiters_leftmost;</span><br><span class="line">	<span class="comment">/* Deadlock detection and priority inheritance handling */</span></span><br><span class="line">	<span class="keyword">struct</span> rt_mutex_waiter *pi_blocked_on;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">	<span class="comment">/* mutex deadlock detection */</span></span><br><span class="line">	<span class="keyword">struct</span> mutex_waiter *blocked_on;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> irq_events;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hardirq_enable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hardirq_disable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hardirq_enable_event;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hardirq_disable_event;</span><br><span class="line">	<span class="keyword">int</span> hardirqs_enabled;</span><br><span class="line">	<span class="keyword">int</span> hardirq_context;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> softirq_disable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> softirq_enable_ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_disable_event;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_enable_event;</span><br><span class="line">	<span class="keyword">int</span> softirqs_enabled;</span><br><span class="line">	<span class="keyword">int</span> softirq_context;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_LOCKDEP</span></span><br><span class="line"><span class="preprocessor"># <span class="keyword">define</span> MAX_LOCK_DEPTH 48UL</span></span><br><span class="line">	u64 curr_chain_key;</span><br><span class="line">	<span class="keyword">int</span> lockdep_depth;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lockdep_recursion;</span><br><span class="line">	<span class="keyword">struct</span> held_lock held_locks[MAX_LOCK_DEPTH];</span><br><span class="line">	gfp_t lockdep_reclaim_gfp;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* journalling filesystem info */</span></span><br><span class="line">	<span class="keyword">void</span> *journal_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* stacked block device info */</span></span><br><span class="line">	<span class="keyword">struct</span> bio_list *bio_list;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_BLOCK</span></span><br><span class="line"><span class="comment">/* stack plugging */</span></span><br><span class="line">	<span class="keyword">struct</span> blk_plug *plug;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* VM state */</span></span><br><span class="line">	<span class="keyword">struct</span> reclaim_state *reclaim_state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> backing_dev_info *backing_dev_info;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> io_context *io_context;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace_message;</span><br><span class="line">	siginfo_t *last_siginfo; <span class="comment">/* For ptrace use.  */</span></span><br><span class="line">	<span class="keyword">struct</span> task_io_accounting ioac;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(CONFIG_TASK_XACCT)</span></span><br><span class="line">	u64 acct_rss_mem1;	<span class="comment">/* accumulated rss usage */</span></span><br><span class="line">	u64 acct_vm_mem1;	<span class="comment">/* accumulated virtual memory usage */</span></span><br><span class="line">	cputime_t acct_timexpd;	<span class="comment">/* stime + utime since last update */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_CPUSETS</span></span><br><span class="line">	nodemask_t mems_allowed;	<span class="comment">/* Protected by alloc_lock */</span></span><br><span class="line">	seqcount_t mems_allowed_seq;	<span class="comment">/* Seqence no to catch updates */</span></span><br><span class="line">	<span class="keyword">int</span> cpuset_mem_spread_rotor;</span><br><span class="line">	<span class="keyword">int</span> cpuset_slab_spread_rotor;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* Control Group info protected by css_set_lock */</span></span><br><span class="line">	<span class="keyword">struct</span> css_set __rcu *cgroups;</span><br><span class="line">	<span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head cg_list;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_FUTEX</span></span><br><span class="line">	<span class="keyword">struct</span> robust_list_head __user *robust_list;</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_COMPAT</span></span><br><span class="line">	<span class="keyword">struct</span> compat_robust_list_head __user *compat_robust_list;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> list_head pi_state_list;</span><br><span class="line">	<span class="keyword">struct</span> futex_pi_state *pi_state_cache;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PERF_EVENTS</span></span><br><span class="line">	<span class="keyword">struct</span> perf_event_context *perf_event_ctxp[perf_nr_task_contexts];</span><br><span class="line">	<span class="keyword">struct</span> mutex perf_event_mutex;</span><br><span class="line">	<span class="keyword">struct</span> list_head perf_event_list;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> preempt_disable_ip;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">struct</span> mempolicy *mempolicy;	<span class="comment">/* Protected by alloc_lock */</span></span><br><span class="line">	<span class="keyword">short</span> il_next;</span><br><span class="line">	<span class="keyword">short</span> pref_node_fork;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="keyword">int</span> numa_scan_seq;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> numa_scan_period;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> numa_scan_period_max;</span><br><span class="line">	<span class="keyword">int</span> numa_preferred_nid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numa_migrate_retry;</span><br><span class="line">	u64 node_stamp;			<span class="comment">/* migration stamp  */</span></span><br><span class="line">	u64 last_task_numa_placement;</span><br><span class="line">	u64 last_sum_exec_runtime;</span><br><span class="line">	<span class="keyword">struct</span> callback_head numa_work;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> list_head numa_entry;</span><br><span class="line">	<span class="keyword">struct</span> numa_group *numa_group;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * numa_faults is an array split into four regions:</span><br><span class="line">	 * faults_memory, faults_cpu, faults_memory_buffer, faults_cpu_buffer</span><br><span class="line">	 * in this precise order.</span><br><span class="line">	 *</span><br><span class="line">	 * faults_memory: Exponential decaying average of faults on a per-node</span><br><span class="line">	 * basis. Scheduling placement decisions are made based on these</span><br><span class="line">	 * counts. The values remain static for the duration of a PTE scan.</span><br><span class="line">	 * faults_cpu: Track the nodes the process was running on when a NUMA</span><br><span class="line">	 * hinting fault was incurred.</span><br><span class="line">	 * faults_memory_buffer and faults_cpu_buffer: Record faults per node</span><br><span class="line">	 * during the current scan window. When the scan completes, the counts</span><br><span class="line">	 * in faults_memory and faults_cpu decay and these values are copied.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *numa_faults;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> total_numa_faults;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * numa_faults_locality tracks if faults recorded during the last</span><br><span class="line">	 * scan window were remote/local or failed to migrate. The task scan</span><br><span class="line">	 * period is adapted based on the locality of the faults with different</span><br><span class="line">	 * weights depending on whether they were shared or private faults</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numa_faults_locality[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numa_pages_migrated;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* CONFIG_NUMA_BALANCING */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * cache last used pipe for splice</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> pipe_inode_info *splice_pipe;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> page_frag task_frag;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef	CONFIG_TASK_DELAY_ACCT</span></span><br><span class="line">	<span class="keyword">struct</span> task_delay_info *delays;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_FAULT_INJECTION</span></span><br><span class="line">	<span class="keyword">int</span> make_it_fail;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * when (nr_dirtied &gt;= nr_dirtied_pause), it's time to call</span><br><span class="line">	 * balance_dirty_pages() for some dirty throttling pause</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">int</span> nr_dirtied;</span><br><span class="line">	<span class="keyword">int</span> nr_dirtied_pause;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dirty_paused_when; <span class="comment">/* start of a write-and-pause period */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_LATENCYTOP</span></span><br><span class="line">	<span class="keyword">int</span> latency_record_count;</span><br><span class="line">	<span class="keyword">struct</span> latency_record latency_record[LT_SAVECOUNT];</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * time slack values; these are used to round up poll() and</span><br><span class="line">	 * select() etc timeout values. These are in nanoseconds.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timer_slack_ns;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> default_timer_slack_ns;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_KASAN</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> kasan_depth;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span></span><br><span class="line">	<span class="comment">/* Index of current stored address in ret_stack */</span></span><br><span class="line">	<span class="keyword">int</span> curr_ret_stack;</span><br><span class="line">	<span class="comment">/* Stack of return addresses for return function tracing */</span></span><br><span class="line">	<span class="keyword">struct</span> ftrace_ret_stack	*ret_stack;</span><br><span class="line">	<span class="comment">/* time stamp for last schedule */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ftrace_timestamp;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Number of functions that haven't been traced</span><br><span class="line">	 * because of depth overrun.</span><br><span class="line">	 */</span></span><br><span class="line">	atomic_t trace_overrun;</span><br><span class="line">	<span class="comment">/* Pause for the tracing */</span></span><br><span class="line">	atomic_t tracing_graph_pause;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_TRACING</span></span><br><span class="line">	<span class="comment">/* state flags for use by tracers */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> trace;</span><br><span class="line">	<span class="comment">/* bitmask and counter of trace recursion */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> trace_recursion;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* CONFIG_TRACING */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_MEMCG</span></span><br><span class="line">	<span class="keyword">struct</span> memcg_oom_info &#123;</span><br><span class="line">		<span class="keyword">struct</span> mem_cgroup *memcg;</span><br><span class="line">		gfp_t gfp_mask;</span><br><span class="line">		<span class="keyword">int</span> order;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> may_oom:<span class="number">1</span>;</span><br><span class="line">	&#125; memcg_oom;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_UPROBES</span></span><br><span class="line">	<span class="keyword">struct</span> uprobe_task *utask;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(CONFIG_BCACHE) || defined(CONFIG_BCACHE_MODULE)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	sequential_io;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	sequential_io_avg;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	task_state_change;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct task_struct，被放在 process 的 kernel stack 的最後，因此可以藉由 stack pointer 來取得 PCB，
不過在 2.6.22 以後已不用此方法。
當 PCB allocaed，Linux 會一併 allocate struct thead_info，thread_info 會被 push 至 stask 的 top，
而 thread_info 的第一個 member 則指向 task_struct。</p>
<p>x86
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">asm</span>/thread_info&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread_info &#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct	*task;		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="keyword">struct</span> exec_domain	*exec_domain;	<span class="comment">/* execution domain */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_preempt_count;</span><br><span class="line">	mm_segment_t		addr_limit;</span><br><span class="line">	<span class="keyword">void</span> __user		*sysenter_return;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uaccess_err:<span class="number">1</span>;	<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>x86
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">asm</span>/current.h&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef __ASSEMBLY__</span></span><br><span class="line"><span class="keyword">struct</span> task_struct;</span><br><span class="line"></span><br><span class="line">DECLARE_PER_CPU(<span class="keyword">struct</span> task_struct *, current_task);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">struct</span> task_struct *get_current(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> this_cpu_read_stable(current_task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> current get_current()</span></span><br></pre></td></tr></table></figure>
<p>每個 process 都有個 pid，type pid_t (int)
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure></p>
<p>可以知道最大的pid value</p>
<p>實際上 maximum pid 定義在
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;linux/threads.h&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * This controls the default maximum pid allocated to a process</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PID_MAX_DEFAULT (CONFIG_BASE_SMALL ? 0x1000 : 0x8000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * A maximum of 4 million PIDs should be enough for a while.</span><br><span class="line"> * [NOTE: PID/TIDs are limited to 2^29 ~= 500+ million, see futex.h.]</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PID_MAX_LIMIT (CONFIG_BASE_SMALL ? PAGE_SIZE * 8 : \</span></span><br><span class="line">	(<span class="keyword">sizeof</span>(<span class="keyword">long</span>) &gt; <span class="number">4</span> ? <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span> : PID_MAX_DEFAULT))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Define a minimum number of pids per cpu.  Heuristically based</span><br><span class="line"> * on original pid max of 32k for 32 cpus.  Also, increase the</span><br><span class="line"> * minimum settable value for pid_max on the running system based</span><br><span class="line"> * on similar defaults.  See kernel/pid.c:pidmap_init() for details.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PIDS_PER_CPU_DEFAULT	1024</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PIDS_PER_CPU_MIN	8</span></span><br></pre></td></tr></table></figure>
<h3 id="Process_State">Process State</h3><p>process state 定義在
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;linux/sched.h&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Task state bitmask. NOTE! These bits are also</span><br><span class="line"> * encoded in fs/proc/array.c: get_task_state().</span><br><span class="line"> *</span><br><span class="line"> * We have two separate sets of flags: task-&gt;state</span><br><span class="line"> * is about runnability, while task-&gt;exit_state are</span><br><span class="line"> * about the task exiting. Confusing, but this way</span><br><span class="line"> * modifying one set can't modify the other one by</span><br><span class="line"> * mistake.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_RUNNING		0</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_INTERRUPTIBLE	1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE	2</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __TASK_STOPPED		4</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __TASK_TRACED		8</span></span><br><span class="line"><span class="comment">/* in tsk-&gt;exit_state */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EXIT_DEAD		16</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EXIT_ZOMBIE		32</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EXIT_TRACE		(EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"><span class="comment">/* in tsk-&gt;state again */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_DEAD		64</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_WAKEKILL		128</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_WAKING		256</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_PARKED		512</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_STATE_MAX		1024</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_STATE_TO_CHAR_STR "RSDTtXZxKWP"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> ___assert_task_state[<span class="number">1</span> - <span class="number">2</span>*!!(</span><br><span class="line">		<span class="keyword">sizeof</span>(TASK_STATE_TO_CHAR_STR)-<span class="number">1</span> != ilog2(TASK_STATE_MAX)+<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of set_task_state */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_KILLABLE		(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_STOPPED		(TASK_WAKEKILL | __TASK_STOPPED)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_TRACED		(TASK_WAKEKILL | __TASK_TRACED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of wake_up */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_NORMAL		(TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_ALL		(TASK_NORMAL | __TASK_STOPPED | __TASK_TRACED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* get_task_state() */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TASK_REPORT		(TASK_RUNNING | TASK_INTERRUPTIBLE | \</span></span><br><span class="line">				 TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \</span><br><span class="line">				 __TASK_TRACED | EXIT_ZOMBIE | EXIT_DEAD)</span><br></pre></td></tr></table></figure>
<p>struct task_struct-&gt;state</p>
<ul>
<li>TASK_RUNNING: The process is runnable, (running or watting to run)</li>
<li>TASK_INTERRUPTIBLE: The process is sleeping (blocking), wake up and become runnable if it receives a signal.</li>
<li>TASK_UNINTERRUPTIBLE: 與 TASK_INTERRUPTIBLE 很像，但他不會被因收到 signal 而變成 runnable</li>
<li>__TASK_TRACED: The process is being traced by another process, ex ptrace</li>
<li>__TASK_STOPPED: Process execution has stopped; the task is not running nor is it
eligible to run.This occurs if the task receives the SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU signal or if it receives
any signal while it is being debugged</li>
</ul>
<h3 id="Process_Context">Process Context</h3><p>process 是在 user-space 執行的，當呼叫到 system call，會進入 kernel-space，
此時 kernel 是在 process-context，current macro 會指到 呼叫 system call 的 process。</p>
<h3 id="Process_Creation">Process Creation</h3><p>Linux 藉由fork(), exec() 來完成 process 的 creation。
fork() 會 copy 一份 task_struct，更新 PID, PPID, 以及一些。
最後exec() 會載入 executable 至 address space然後執行。</p>
<h3 id="Copy-on-Write">Copy-on-Write</h3><h3 id="Forking">Forking</h3><p>fork(), 主要由 clone() system call 實作，clone() 則是呼叫 do_fork()。</p>
<p>linux/kernel/fork.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *  Ok, this is the main fork-routine.</span><br><span class="line"> *</span><br><span class="line"> * It copies the process, and if successful kick-starts</span><br><span class="line"> * it and waits for it to finish using the VM if required.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span><br><span class="line">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span><br><span class="line">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span><br><span class="line">	      <span class="keyword">int</span> __user *parent_tidptr,</span><br><span class="line">	      <span class="keyword">int</span> __user *child_tidptr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct *p;</span><br><span class="line">	<span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Determine whether and which event to report to ptracer.  When</span><br><span class="line">	 * called from kernel_thread or CLONE_UNTRACED is explicitly</span><br><span class="line">	 * requested, no event is reported; otherwise, report if the event</span><br><span class="line">	 * for the type of forking is enabled.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(clone_flags &amp; CLONE_UNTRACED)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">			trace = PTRACE_EVENT_VFORK;</span><br><span class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">((clone_flags &amp; CSIGNAL)</span> !</span>= SIGCHLD)</span><br><span class="line">			trace = PTRACE_EVENT_CLONE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			trace = PTRACE_EVENT_FORK;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!ptrace_event_enabled(current, trace)))</span><br><span class="line">			trace = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">			 child_tidptr, NULL, trace);</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Do this prior waking up the new thread - the thread pointer</span><br><span class="line">	 * might get invalid after that point, if the thread exits quickly.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">		<span class="keyword">struct</span> completion vfork;</span><br><span class="line">		<span class="keyword">struct</span> pid *pid;</span><br><span class="line"></span><br><span class="line">		trace_sched_process_fork(current, p);</span><br><span class="line"></span><br><span class="line">		pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">		nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">			put_user(nr, parent_tidptr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">			init_completion(&amp;vfork);</span><br><span class="line">			get_task_struct(p);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* forking complete and child started to run, tell ptracer */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(trace))</span><br><span class="line">			ptrace_event_pid(trace, pid);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">				ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		put_pid(pid);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		nr = PTR_ERR(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 do_fork() 中看到了 copy_process()，這裡開始產稱一個 process。
copy_process() 主要會作：</p>
<ol>
<li>calls dup_task_struct(), which creates a new kernel stack, thread_info, task_struct.
kernel stack 的大小為 THREAD_SIZE(2 * PAGE_SIZE)</li>
<li>確認新的 process 不會超出user 使用的 process 個數的限制，以及 resource的限制。</li>
<li>initialize task_struct 的 member。</li>
<li>把 process state 設為 TASK_UNINTERRUPTIBLE，確保不會被執行。(我找不到這段code)</li>
<li>update task_struct-&gt;flags</li>
<li><p>根據 clone() 的 flags 來決定哪些 resource 要 copy。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clear superuser privilege and worker flag */</span></span><br><span class="line">p-&gt;flags &amp;= ~(PF_SUPERPRIV | PF_WQ_WORKER);</span><br><span class="line"><span class="comment">/* 表示尚未 exec() */</span></span><br><span class="line">p-&gt;flags |= PF_FORKNOEXEC;</span><br></pre></td></tr></table></figure>
</li>
<li><p>return task_struct</p>
</li>
<li>calls alloc_pid()</li>
</ol>
<p>回到do_fork(), wake up new process and run。</p>
<h3 id="vfork:">vfork:</h3><ul>
<li><p>在copy_process()裡的copy_mm()，不會 copy task_struct-&gt;mm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">	atomic_inc(&amp;oldmm-&gt;mm_users);</span><br><span class="line">	mm = oldmm;</span><br><span class="line">	<span class="keyword">goto</span> good_mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>會assign vfork_done，</p>
</li>
<li>child 執行後，parent 會等待 vfork_done，直到 vfork_done completion，並送出 signal<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">		ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x86 asm/page_32_types.h</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> THREAD_SIZE_ORDER	1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> THREAD_SIZE		(PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x86_64 asm/page_64_types.h</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_KASAN</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> KASAN_STACK_ORDER 1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> KASAN_STACK_ORDER 0</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> THREAD_SIZE_ORDER	(2 + KASAN_STACK_ORDER)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CURRENT_MASK (~(THREAD_SIZE - 1))</span></span><br></pre></td></tr></table></figure>
<p>寫個 fork 程式來確認一下使用到的 參數
可以利用 strace 來 trace system call。
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clone</span>(child_stack=<span class="number">0</span>, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=<span class="number">0</span>x7<span class="built_in">fc</span>28d9089d0) = <span class="number">22146</span></span><br></pre></td></tr></table></figure></p>
<p>C library 的 fork 使用的是 clone()，
flags = CLONE_CHILD_CREARTID | CLONE_CHILD_SETTID | SIGCHILD</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2015/04/15/Process-Creation/" data-id="ciho8m29z000g43if275vd705" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2014/01/01/hello-world/" class="article-date">
  <time datetime="2013-12-31T16:00:00.000Z" itemprop="datePublished">2014-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/Hello/">Hello</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2014/01/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://forceablaze.github.io/blog/2014/01/01/hello-world/" data-id="ciho8m29o000443ifvicu0wf2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Hello/">Hello</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Hello/">Hello</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C/">C</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Hello/">Hello</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux-Network-KVM/">Linux,Network,KVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux-qemu/">Linux,qemu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Network/">Network</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/C/" style="font-size: 20px;">C</a><a href="/blog/tags/Hello/" style="font-size: 10px;">Hello</a><a href="/blog/tags/Linux/" style="font-size: 20px;">Linux</a><a href="/blog/tags/Linux-Network-KVM/" style="font-size: 10px;">Linux,Network,KVM</a><a href="/blog/tags/Linux-qemu/" style="font-size: 10px;">Linux,qemu</a><a href="/blog/tags/Network/" style="font-size: 10px;">Network</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/06/">June 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/05/">May 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/04/">April 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/01/">January 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2015/09/24/qcow2-format/">qcow2 format</a>
          </li>
        
          <li>
            <a href="/blog/2015/09/22/Software-switches-in-Linux/">Software switches in Linux</a>
          </li>
        
          <li>
            <a href="/blog/2015/06/15/fPIC/">fPIC</a>
          </li>
        
          <li>
            <a href="/blog/2015/05/25/OSI-Model/">OSI Model</a>
          </li>
        
          <li>
            <a href="/blog/2015/04/30/Memory-Management/">Memory Management</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>